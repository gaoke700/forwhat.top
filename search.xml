<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[JS逻辑运算符及优先级]]></title>
      <url>http://yoursite.com/2016/02/17/jsPriority/</url>
      <content type="html"><![CDATA[<h2 id="js中的真假"><a href="#js中的真假" class="headerlink" title="js中的真假"></a>js中的真假</h2><p>js中的假: <mark> false </mark>毋庸置疑  , 空<mark> null </mark> , 数字<mark> 0 </mark> , 空字符串 <mark> “” </mark> , 非数字<mark> NaN </mark> , 还有<mark> undefined </mark></p>
<p>js中的真: 除了上面的假之外都是真,包括字符串 “false” , 对象 等<br><a id="more"></a></p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>a &amp;&amp; b :如果 a 为true，直接返回b，而不管 b 为 true 或者 false 。如果 a 为false 那么直接返回 a</p>
<p>a || b :如果 a 为true，直接返回a，而不会继续往下执行。如果 a 为 false，直接返回b，而不管 b为 true 或者false</p>
<p>先看个例1:</p>
<pre><code>var a = 1 &amp;&amp; 2 &amp;&amp; 3; 
var b = 0 &amp;&amp; 1 &amp;&amp; 2; 
var c = 1 &amp;&amp; 0 &amp;&amp; 2;
alert(a)                    //3 
alert(b)                    //0 
alert(c);                    //0  
</code></pre><p>上面例子中第一个: 因为1 &amp;&amp; 2，1为真，返回2；2&amp;&amp;3， 2为真，返回3 , <mark>&amp;&amp;(逻辑与)运算一假即假</mark> ,遇到false就返回</p>
<p>再看个例2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 0 || 1 || 2;</span><br><span class="line">var b = 1 || 0 || 3; </span><br><span class="line">alert(a)						//1  </span><br><span class="line">alert(b);						//1</span><br></pre></td></tr></table></figure>
<p>上面第一个: 0 || 1 , 0为假,返回 1,  1||2 , 1 为真 返回 1 不再执行了 , <mark>||(逻辑或)运算一真即真</mark> ,遇到true就返回</p>
<p>&amp;&amp;(逻辑与)和||(逻辑或)混合使用的时候要注意他们的优先级：<mark> &amp;&amp;(逻辑与)优先级高于||(逻辑或） </mark></p>
<p>再看个例3:</p>
<pre><code>var a = 3 &amp;&amp; 0 || 2;    
var b = 3 || 0 &amp;&amp; 2; 
var c = 0 || 2 &amp;&amp; 3;   
alert(a)                    //2 
alert(b)                     //3  
alert(c);                    //3
</code></pre><p>上面第三个: 注意先算的是后面的逻辑与, 2 &amp;&amp; 3 返回 3  , 再 0 || 3 ,返回 3 ;<br>每个逻辑表达式都是有返回值的，但这个值并不一定是布尔变量，下面分别介绍：</p>
<h3 id="与操作符（-amp-amp-）"><a href="#与操作符（-amp-amp-）" class="headerlink" title="与操作符（&amp;&amp;）"></a>与操作符（&amp;&amp;）</h3><p>javascript依次获取每一个操作数，将它们转换为布尔变量，如果是false，则直接返回这个操作数的值（注意，返回的是转换前的原值，不一定是布尔类型），中断后面操作数的处理；否则继续处理下一个操作数。如果直到最后一个操作数仍然对应布尔变量true，则返回最后这个操作数的值。</p>
<p>下面的代码演示了其执行原理：</p>
<pre><code>var a = &quot;1&quot; &amp;&amp; true &amp;&amp; 0 &amp;&amp; false &amp;&amp; &quot;abc&quot;;  
alert(a);                          //可见a的值是0  
var b = &quot;abc&quot; &amp;&amp; true &amp;&amp; &quot;123&quot;;  
alert(b);                          //可见b的值是&quot;123&quot;;
</code></pre><h3 id="或操作符（-）"><a href="#或操作符（-）" class="headerlink" title="或操作符（||）"></a>或操作符（||）</h3><p>javascript依次获取每一个操作数，将它们转换为布尔变量，如果是true，则直接返回这个操作数的值，中断后面操作数的处理；否则继续下一个操作数。如果知道最后一个操作数仍然对应布尔变量false，则返回这个操作数的值。</p>
<p>下面的代码演示了其执行原理：    </p>
<pre><code>var a = &quot;abc&quot; || &quot;123&quot;;  
alert(a);                          //可见a的值是&quot;abc&quot;  
var b = false || &quot;&quot; || 0;  
alert(b);                         //可见a的值是0
</code></pre><h3 id="非操作符（-）"><a href="#非操作符（-）" class="headerlink" title="非操作符（!）"></a>非操作符（!）</h3><p>和前两种操作符不同，非操作符始终返回布尔类型的变量 ，例如：</p>
<pre><code>var a = ! &quot;abc&quot;;  
alert(a);                     //显示a的值为false
</code></pre><h2 id="js运算优先级"><a href="#js运算优先级" class="headerlink" title="js运算优先级"></a>js运算优先级</h2><p>JScript 中的运算符优先级是一套规则。该规则在计算表达式时控制运算符执行的顺序。具有较高优先级的运算符先于较低优先级的运算符执行。例如，乘法的执行先于加法。</p>
<p>下表按从最高到最低的优先级列出 JScript 运算符。 <mark> 具有相同优先级的运算符按从左至右的顺序求值</mark> 。</p>
<pre><code>运算符                                        描述

.      []     ()                            字段访问、数组下标、函数调用以及表达式分组
++ -- - ~ ! delete new typeof void            一元运算符、返回数据类型、对象创建、未定义值
*         /       %                            乘法、除法、取模
+         -        +                            加法、减法、字符串连接
&lt;&lt;     &gt;&gt;     &gt;&gt;&gt;                            移位
&lt;   &lt;=   &gt;   &gt;=   instanceof                小于、小于等于、大于、大于等于、instanceof
==    !=    ===    !==                        等于、不等于、严格相等、非严格相等
&amp;                                            按位与
^                                            按位异或
|                                            按位或
&amp;&amp;                                            逻辑与
||                                            逻辑或
?:                                            条件
=      oP=                                    赋值、运算赋值
,                                            多重求值
</code></pre><p>圆括号可用来改变运算符优先级所决定的求值顺序。这意味着圆括号中的表达式应在其用于表达式的其余部分之前全部被求值。    </p>
<p>例如：</p>
<pre><code>z = 78 * (96 + 3 + 45)
</code></pre><p>根据运算符优先级的规则，首先对圆括号内的表达式求值。圆括号中有两个加法运算符。因为两个加法运算符具有相同的优先级，从左到右求值。先将 96 和 3 相加，然后将其和与 45 相加，得到的结果为 144。</p>
<p>然后是乘法运算。78 乘以 144，得到结果为 11232。</p>
<p>最后是赋值运算。将 11232 赋给 z。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript中with语句优缺点]]></title>
      <url>http://yoursite.com/2016/02/11/with/</url>
      <content type="html"><![CDATA[<p>对于开发,优化始终应该是我需要努力的方向,今天来讲讲JavaScript中with语句:</p>
<p>with语句的作用是暂时改变作用域链、减少的重复输入</p>
<p>其语法结构为：</p>
<pre><code>with(object){
    //statements
}
</code></pre><a id="more"></a>
<p>例如:</p>
<pre><code>with(document.forms[0]){  
   name.value = &quot;lee king&quot;;  
   address.value = &quot;Peking&quot;;  
   zipcode.value = &quot;10000&quot;;  
}  
</code></pre><p>与之对应的传统的写法是：</p>
<pre><code>document.forms[0].name.value = &quot;lee king&quot;;  
document.forms[0].address.value = &quot;Peking&quot;;  
document.forms[0].zipcode.value = &quot;10000&quot;; 
</code></pre><p>可以看出with语句的简洁明了.</p>
<p>不过在代码的世界里是很难找到真正的完美。js的解释器需要检查with块中的变量是否属于with包含的对象，这将使with语句执行速度大大下降，并且导致js语句很难被优化。</p>
<p>为了兼顾速度与代码量可以找到一个比较折衷的方案：</p>
<pre><code>var  form = document.forms[0];  
form.name.value = &quot;lee king&quot;;  
form.address.value = &quot;Peking&quot;;  
form.zipcode.value = &quot;10000&quot;;
</code></pre><p>讲这个知识点只是为了让我们能看懂别人的代码,个人建议在以后的高效代码开发中我们应该尽可能的避免使用with语句。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[javascript中的apply()和call()方法]]></title>
      <url>http://yoursite.com/2016/02/04/call/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h2><p>JavaScrtipt动态变换上下文相关对象时,主要运用apply, call两个方法.</p>
<p>call, apply都属于Function.prototype的一个方法,它是JavaScript引擎内在实现的,因为属于Function.prototype,所以每个Function对象实例,也就是每个方法都有call, apply属性.</p>
<p>既然作为方法的属性,那它们的使用就当然是针对方法的了,这两个方法是容易混淆的,因为它们的作用一样,只是使用方式不同.<br><a id="more"></a><br>区分apply,call就一句话:</p>
<pre><code>foo.call(this, arg1,arg2,arg3) == foo.apply(this, arguments)==this.foo(arg1, arg2, arg3)
</code></pre><p>相同点:两个方法产生的作用是完全一样的</p>
<p>不同点:方法传递的参数不同</p>
<p>上面代码中,foo是一个方法,this是方法执行时上下文相关对象,arg1, arg2, arg3是传给foo方法的参数.这里所谓的方法执行时上下文相关对象, 如果有面向对象的编程基础,那很好理解,就是在类实例化后对象中的this.</p>
<h2 id="作用相同"><a href="#作用相同" class="headerlink" title="作用相同"></a>作用相同</h2><p>在JavaScript中,代码总是有一个上下文对象,代码处于该对象之内. 上下文对象是通过this变量来体现的, 这个this变量永远指向当前代码所处的对象中.</p>
<p>为了更好的领会这this是什么,举个例子:</p>
<pre><code>function A(){
    this.message = &quot;我A的是消息&quot;
    this.getMessage = function(){
        return this.message
    }
}
function B(){
    this.message = &quot;我B的是消息&quot;
    this.setMessage = function(newMessage){
        this.message = newMessage
    }
}
</code></pre><p>可见,A, B类都有一个message属性(面向对象中所说的成员),A有获取消息的getMessage方法,B有设置消息的setMessage方法,下面来显示call的威力.</p>
<pre><code>var a = new A();
var b = new B();
b.setMessage.call(a, &quot;a的消息&quot;);        //给对象a动态指派b的setMessage方法,注意,a本身是没有这方法的!
alert(a.getMessage());                //显示&quot;a的消息&quot;
alert(a.getMessage.call(b))    ;        //给对象b动态指派a的getMessage方法,结果显示&quot;我B的是消息&quot;
</code></pre><p>简直是”无中生有”,对象的方法可以任意指派,而对象本身一直都是没有这方法的,注意是指派,通俗点就是,方法是借给另一个对象的调用去完成任务,原理上是方法执行时上下文对象改变了.</p>
<p>所以 b.setMessage.call(a, “a的消息”); 就等于用 a 作执行时上下文对象调用b对象的 setMessage 方法,而这过程中与 b 一点关系都没有, 作用等效于 a.setMessage( “a的消息”);</p>
<p>因为 apply 与 call 产生的作用是一样的,可以说 call, apply 作用就是借用别人的方法来调用,就像调用自己的一样    </p>
<h2 id="传参区别"><a href="#传参区别" class="headerlink" title="传参区别"></a>传参区别</h2><p>理解了call, apply相同处—–作用后,再来看看它们的区别,看过上面例子,相信您大概知道了,从 b.setMessage.call(a, “a的消息”) 等效于 a.setMessage( “a的消息”) 可以看出, “a的消息”在call中作为一个参数传递.</p>
<p>那么在apply中是怎么表示的呢,直接解释说不清楚,apply要结合应用场景才一目了然.我们来设计一个应用场景:</p>
<pre><code>function print(a, b, c, d){
    alert(a + b + c + d);
}
function example(a, b , c , d){
    print.call(this, a, b, c, d);        //用call方式借用print,参数显式打散传递
    print.apply(this, arguments);        //用apply方式借用print, 参数作为一个数组传递
                    //这里直接用JavaScript方法内本身有的arguments数组
    print.apply(this, [a, b, c, d]);    //或者封装成数组
}
example(”背” , “光” , “脚”, “本”);        //弹出三次”背光脚本”
</code></pre><p>在这场景中, example方法内,a, b, c, d作为方法传递的参数, 方法分别运用了apply, call去借print方法来调用,</p>
<p>最后一句由于直接调用example方法, 所以在该方法中的上下文对象this就是window对象.</p>
<p>所以,call, apply方法它们除了第一个参数,即执行时上下文对象相同外,call方法的其它参数将依次传递给借用的方法作参数,而apply就两个参数,第二个参数为一个数组传递.所以可以说成:</p>
<pre><code>call, apply方法区别是,从第二个参数起, call方法参数将依次传递给借用的方法作参数, 而apply直接将这些参数放到一个数组中再传递, 最后借用方法的参数列表是一样的.    
</code></pre><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>当参数明确时可用 call , 当参数不明确时可用 apply 给合 arguments ,例:</p>
<pre><code>print.call(window, “背” , “光” , “脚”, “本”);                            
function foo(){
    print.apply(window, arguments);            //foo参数可能为多个
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端面试题4]]></title>
      <url>http://yoursite.com/2016/01/29/interview4/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p>1 . HTML5中的datalist是什么？并且写出Datalist功能的HTML代码</p>
<p>2 . 如果你显示中使用的是Google Chrome，如何让input元素默认情况下显示”HiCling Team”，而在光标一入后显示空白？</p>
<p>3 . 创建一个显示含有本地时间的日历的input<br><a id="more"></a><br>4 . 判断下面字符串中出现次数最多的字符，同级这个次数。</p>
<p>   var str = ‘asdfssaaaasasasasaa’</p>
<p>5 . 超链接访问过后 hover 样式就不出现的问题是什么?如何解决？</p>
<p>6 . 如何垂直居中一个元素？（1.已知高度100X100；2.位置高度的）</p>
<p>7 . var foo=0,bar=1; foo=foo || bar; 这段代码运行后的 foo 的值是什么？</p>
<p>8 . 如何判断 JavaScript 变量的数据类型？</p>
<p>9 . 编码实现：获取页面中 id 为 test 的元素并添加时间处理函数，处理函数用来取消事件冒泡和阻止对象默认行为</p>
<p>10 . 跨域请求数据的解决方案有哪些？</p>
<p>11 . 写出你所知道的所有 JavaScript 函数的定义方法</p>
<p>12 . 简单实现 jQuery 的 $ ，用JS原生</p>
<p>13 . 说说下面两个表达的区别</p>
<pre><code>$.extend();
$.fn.extend();
</code></pre><p>14 . 移动端屏幕的物理分辨率和逻辑分辨率的区别？</p>
<p>15 . 你做的页面在哪些浏览器测试过？这些浏览器的内核分别是什么？</p>
<p>16 . 解释css sprites作用是什么</p>
<p>17 . Html5响应式设计框架有哪些？</p>
<p>18 . JS中如何阻止时间冒泡和默认事件？</p>
<p>19 . JS的ajax请求出现跨域问题有什么解决办法？</p>
<p>20 . $(this)和this关键字在jQuery中有何不同？</p>
<p>21 . 当项目的某个模块发生问题了，你是怎么定位错误的？你用的调试工具是什么？</p>
<p>22 . 在和后端进行异步请求时，很容易陷入嵌套太深的陷阱？</p>
<p>23 . 一个正则表达式匹配所有二级域名是9game.cn和其目录下的网址，比如http//abc.9game.cn/web/非常重要的时候，怎么保护他呢？</p>
<p>24 . 项目在本地没问题，但是放到线上就有问题了，你是怎么解决的？</p>
<p>25 . 在项目开发完成后，根据雅虎性能优化规则，需要对html,js,css,图片做出怎么的处理？是否可以借助构建工具实现自动化？</p>
<p>26 . 常用布局的实现（两列布局、三列适应布局、两列等高适应布局）</p>
<p>27 . JS如何改变元素属性及CSS值</p>
<p>28 . 常用的DOM操作，新建、添加、删除、移动</p>
<p>29 . jQuery的bind、live、on、delegate的区别</p>
<p>30 . JS变量提升、匿名函数、原型继承、作用域、闭包机制</p>
<p>31 . 对HTML协议的理解</p>
<p>32 . 盒模型介绍（可以画图说明）</p>
<p>33 . 块级元素和行内元素的区别以及如何清除浮动</p>
<p>34 . CSS中position属性有哪几个值，区别是什么？</p>
<p>35 . CSS选择器的种类及优先级</p>
<p>36 . 浏览器兼容问题以及常用的css hack</p>
<p>37 . 请举例 HTML5新增的标签（10个以上）</p>
<p>38 . “abc123”.slice(2,-1)的结果是</p>
<p>39 . “abc123”.substring(2,-1)的结果是</p>
<p>40 . 以下代码执行结果分别是什么？</p>
<pre><code>1.  3+&quot;3&quot;

2.  &quot;23&quot;&gt;&quot;3&quot;

3.  ture &amp;&amp; 2

4.  var a={};
    a.name=&apos;hello aladdin&apos;;
    alert(a.length)

5.    (function(){
        var a=b=“hello aladdin&quot;
    })();
    alert(b)

6.    var a=&apos;hello&apos;;
    (function(){
        var b=&apos;aladdin&apos;;
        alert(a+b)
    })();
    alert(a+b)

7.    var b=1;
    function a(b){
        b=2;
        alert(b);
    };
    a(b);
    alert(b);

8.    for(var i=1;i&lt;=3;i++){
        setTimeout(function(){
            console.log(i);
        },0)
    };
</code></pre><p>41 . 下面的写法有没有问题？</p>
<pre><code>;(function(){
    console.log(“123&quot;)
})();

!function(){
    console.log(“123”);
}();
+function(){}();
~function(){}();
</code></pre><p>42 . 说说下面的值，为什么？</p>
<pre><code>var someone={
    name:”Bob”,
    showName:function(){
        alert(this.name);
    }
}

var other={
    name:Tom”,
    showName:someone.showName
}
other.showName();
</code></pre><p>43 . 说说下面两个函数执行后的结果:</p>
<p>代码片段一:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name=“The Window”;</span><br><span class="line">var object=&#123;</span><br><span class="line">	name:”My Object”,</span><br><span class="line">	getNameFunc:function()&#123;</span><br><span class="line">		return function()&#123;</span><br><span class="line">			return this.name;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(object.get NameFunc()())</span><br></pre></td></tr></table></figure>
<p>代码片段二:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name “The Window”;</span><br><span class="line">var object=&#123;</span><br><span class="line">	name:”My Pbject”,</span><br><span class="line">	getNameFunc:function()&#123;</span><br><span class="line">		var that=this;</span><br><span class="line">		return function()&#123;</span><br><span class="line">			return that.name;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>44 . 简述Jquery中,以下两句的区别:</p>
<pre><code>var $wwe = $(&quot;#w3c div.id&quot;);
var $wwe = $(&quot;#w3c&quot;).find(&quot;div.id&quot;)
</code></pre><p>45 . ajax是否能跨域请求,解决的办法</p>
<p>46 . http和https的区别</p>
<p>47 . attr和prop的区别</p>
<p>48 . HTML标记里,行元素和块元素分别有哪些,有什么区别</p>
<p>49 . 什么是闭包(closure),为什么要用</p>
<p>50 . js中的 call() 和 apply() 方法的区别</p>
<p>51 . 下面这段javascript代码,alert的输出结果是什么?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var msg =&quot;hello&quot;</span><br><span class="line">for (var i=0;i&lt;10;i++)&#123;</span><br><span class="line">	var msg =&quot;hello&quot;+i*2+i;</span><br><span class="line">&#125;</span><br><span class="line">alert(msg);</span><br></pre></td></tr></table></figure>
<p>52 . eval是什么?</p>
<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><h3 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h3><h3 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h3><h3 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h3><h3 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h3><h3 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h3><h3 id="第十一题"><a href="#第十一题" class="headerlink" title="第十一题"></a>第十一题</h3><h3 id="第十二题"><a href="#第十二题" class="headerlink" title="第十二题"></a>第十二题</h3><h3 id="第十三题"><a href="#第十三题" class="headerlink" title="第十三题"></a>第十三题</h3><h3 id="第十四题"><a href="#第十四题" class="headerlink" title="第十四题"></a>第十四题</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端面试题3]]></title>
      <url>http://yoursite.com/2016/01/26/interview3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>知乎上看的几道js面试题,鉴于我们伟大的讲师也被坑错了好几道,所以感觉有必要写篇博客记录一下,不费话了直接上题</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p>1 .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    return typeof arguments;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">A. &quot;object&quot;	  B. &quot;array&quot; 	C. &quot;arguments&quot;	 D. &quot;undefined&quot;</span><br></pre></td></tr></table></figure>
<p>2 .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var f = function g()&#123; return 23; &#125;;</span><br><span class="line">typeof g();</span><br><span class="line"></span><br><span class="line">A. &quot;number&quot; 	B. &quot;undefined&quot;	 C. &quot;function&quot;	 D. Eorror</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>3 .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function(x)&#123;</span><br><span class="line">    delete x;</span><br><span class="line">    return x;</span><br><span class="line">&#125;)(1);</span><br><span class="line"></span><br><span class="line">A. 1	B. null	  C. undefined	 D. Error</span><br></pre></td></tr></table></figure>
<p>4 .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var y = 1, x = y = typeof x;</span><br><span class="line">x;</span><br><span class="line"></span><br><span class="line">A. 1	B. &quot;number&quot;		C. undefined	D. &quot;undefined&quot;</span><br></pre></td></tr></table></figure>
<p>5 .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function f(f)&#123;</span><br><span class="line">    return typeof f();</span><br><span class="line">&#125;)(function()&#123; return 1; &#125;);</span><br><span class="line"></span><br><span class="line">A. &quot;number&quot;		B. &quot;undefined&quot;	 C. &quot;function&quot;	 D. Error</span><br></pre></td></tr></table></figure>
<p>6 .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">  bar: function() &#123; return this.baz; &#125;,</span><br><span class="line">  baz: 1</span><br><span class="line">&#125;;</span><br><span class="line">(function()&#123;</span><br><span class="line">  return typeof arguments[0]();</span><br><span class="line">&#125;)(foo.bar);</span><br><span class="line"></span><br><span class="line">A. &quot;undefined&quot;	B. &quot;object&quot;	  C. &quot;number&quot;	  D. &quot;function&quot;</span><br></pre></td></tr></table></figure>
<p>7 .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">  bar: function()&#123; return this.baz; &#125;,</span><br><span class="line">  baz: 1</span><br><span class="line">&#125;</span><br><span class="line">typeof (f = foo.bar)();</span><br><span class="line"></span><br><span class="line"> A. &quot;undefined&quot;	B. &quot;object&quot;	  C. &quot;number&quot;   D. &quot;function&quot;</span><br></pre></td></tr></table></figure>
<p>8 .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> var f = (function f()&#123; return &quot;1&quot;; &#125;, function g()&#123; return 2; &#125;)();</span><br><span class="line"> typeof f;</span><br><span class="line"> </span><br><span class="line">A. &quot;string&quot;   B. &quot;number&quot;   C. &quot;function&quot;  D. &quot;undefined&quot;</span><br></pre></td></tr></table></figure>
<p>9 .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">if (function f()&#123;&#125;) &#123;</span><br><span class="line">  x += typeof f;</span><br><span class="line">&#125;</span><br><span class="line">x;</span><br><span class="line"></span><br><span class="line">A. 1	 B. &quot;1function&quot;   C. &quot;1undefined&quot;   D. NaN</span><br></pre></td></tr></table></figure>
<p>10 .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x = [typeof x, typeof y][1];</span><br><span class="line">typeof typeof x;</span><br><span class="line"></span><br><span class="line">A. &quot;number&quot;	B. &quot;string&quot;	  C. &quot;undefined&quot;  D. &quot;object&quot;</span><br></pre></td></tr></table></figure>
<p>11 .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function(foo)&#123;</span><br><span class="line">   return typeof foo.bar;</span><br><span class="line"> &#125;)(&#123; foo: &#123; bar: 1 &#125; &#125;);</span><br><span class="line"> </span><br><span class="line"> A、“undefined”   B、“object”   C、“number”   D、Error</span><br></pre></td></tr></table></figure>
<p>12 .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function f()&#123;</span><br><span class="line">    function f()&#123; return 1; &#125;</span><br><span class="line">    return f();</span><br><span class="line">    function f()&#123; return 2; &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">  </span><br><span class="line">  A、1	B、2	  C、Error (e.g. “Too much recursion”)  D、undefined</span><br></pre></td></tr></table></figure>
<p>13 .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123; return f; &#125;</span><br><span class="line">new f() instanceof f;</span><br><span class="line"></span><br><span class="line">A、true		B、false</span><br></pre></td></tr></table></figure>
<p>14 .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with (function(x, undefined)&#123;&#125;) length;</span><br><span class="line"></span><br><span class="line">A、1		B、2		C、undefined		D、Error</span><br></pre></td></tr></table></figure>
<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>来来来,对对答案,看你对了几道:</p>
<p>1.A 2.D 3.A 4.D 5.A 6.A 7.A 8.B 9.C 10.B 11.A 12.B 13.B 14.B</p>
<p>如果还有不理解的,请看解释:</p>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><pre><code>(function(){
    return typeof arguments;
})();
</code></pre><p>arguments是函数的参数(如果不在函数里面,那就跟普通变量一样),是一个对象,虽然像数组:</p>
<pre><code>&gt;    (function(){
        return arguments;
      })();
&lt;.    []                 //输出结果
</code></pre><p>但不是数组:</p>
<pre><code>&gt;    (function(){
        return Array.isArray(arguments);
      })();
&lt;.    false                //输出结果
</code></pre><p>此外，就算是数组,js里面数组也是对象类型,typeof 返回的也是 “object”,所以答案就是object    </p>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><pre><code>var f = function g(){ return 23; };
typeof g();
</code></pre><p>在 JS 里，声明函数只有 2 种方法：</p>
<p>第 1 种： function f(){…} （函数声明）</p>
<p>第 2 种： var f = function(){…} （等号后面必须是匿名函数，这句实质是函数表达式）</p>
<p>除此之外，类似于 var f = function g(){…} 这样的东西统一按 2 方法处理，即在函数外部无法通过 g 访问到函数，因为这已经变成了一个表达式。</p>
<p>但为什么不是 “undefined”？</p>
<p>这里如果求 typeof g ，会返回 undefined，但求的是 g()，所以会去先去调用函数 g，这里就会直接抛出异常，所以是 Error。</p>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>delete 操作符用于删除对象的成员变量，不能删除函数的参数。</p>
<h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><pre><code>var y = 1, x = y = typeof x;
  x;
</code></pre><p>  赋值运算符是从右往左的,刚开始x未定义,typeof x 就是undefined,再赋值给y,再赋值给x</p>
<h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function f(f)&#123;</span><br><span class="line">    return typeof f();</span><br><span class="line">&#125;)(function()&#123; return 1; &#125;);</span><br></pre></td></tr></table></figure>
<p>此题故意搞个参数f误导大家,咱换个参数其实也就是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function f(obj)&#123;</span><br><span class="line">    return typeof obj();</span><br><span class="line">&#125;)(function()&#123; return 1; &#125;);</span><br></pre></td></tr></table></figure>
<p>再看看,它把下面的function(){ return 1; }传给了obj,传参就相当于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function f()&#123;</span><br><span class="line">	var obj=function()&#123;</span><br><span class="line">		 return 1;</span><br><span class="line">	  &#125;</span><br><span class="line">    return typeof obj();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>这不就是typeof一下函数obj的运行结果嘛,那就number了</p>
<h3 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">    bar: function() &#123; return this.baz; &#125;,</span><br><span class="line">    baz: 1</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  (function()&#123;</span><br><span class="line">    return typeof arguments[0]();</span><br><span class="line">  &#125;)(foo.bar)</span><br></pre></td></tr></table></figure>
<p>这道题先把 <mark> foo.bar </mark> 传进去做参数,那 <code> arguments[0] </code> 就是 <mark> foo.bar </mark></p>
<p>也就是返回里面这个函数的 运行结果 的类型,首先,在上个函数里 this 指向的是 foo ,我们要看在这个函数里 this 指向的是谁:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;	var foo = &#123;</span><br><span class="line">   	 	bar: function() &#123; return this &#125;,</span><br><span class="line">    	baz: 1</span><br><span class="line">  	&#125;;</span><br><span class="line">  	(function()&#123;</span><br><span class="line">    	return arguments[0]();</span><br><span class="line">  	&#125;)(foo.bar);</span><br><span class="line">&lt;.	[function foo.bar()]		//输出结果</span><br></pre></td></tr></table></figure>
<p>经测试得知,这里的 this 指的是 arguments,原题中baz是foo的,不是foo.bar的,所以是undefined</p>
<h3 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h3><pre><code>var foo = {
bar: function(){ return this.baz; },
baz: 1
  }
  typeof (f = foo.bar)();
</code></pre><p>如果是 foo.bar(),那结果就是1 , 而进行 f = foo.bar 赋值后,this的指向从foo变成了window,而window并没有baz这个属性,所以是undefined</p>
<h3 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h3><pre><code>var f = (function f(){ return &quot;1&quot;; }, function g(){ return 2; })();
typeof f;
</code></pre><p>逗号操作符用于声明多个变量;除此之外,逗号操作符还可以用于赋值,在用于赋值时,逗号操作符总是返回表达式中的最后一项,如:</p>
<pre><code>var num = (3,5,7,2,9,6)        //num的值为6
</code></pre><p>所以本题只有最后面的函数会被执行,所以 f 的值是2</p>
<h3 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">if (function f()&#123;&#125;) &#123;</span><br><span class="line"> 	x += typeof f;</span><br><span class="line">&#125;</span><br><span class="line">x;</span><br></pre></td></tr></table></figure>
<p>注意判断条件里的function f(){}不是函数声明,会被转换成true(非0即真),因此f未定义</p>
<p>如果在判断条件里赋值操作,比如上面换为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">if (f=function()&#123;&#125;) &#123;</span><br><span class="line"> 	x += typeof f;</span><br><span class="line">&#125;</span><br><span class="line">x;</span><br></pre></td></tr></table></figure>
<p>那么,结果就是1function</p>
<h3 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x = [typeof x, typeof y][1];</span><br><span class="line">typeof typeof x;</span><br></pre></td></tr></table></figure>
<p>这题我们可以直接忽略上一行,下一行不管 x 是什么类型,typeof返回的是一个字符串, 也就是再次typeof的结果,也就是说两个typeof后面跟任何一个变量输出的结果都是string类型</p>
<p>咱们再回头来看看第一行,也就是把typeof y 赋值给x , y未定义, 所以 x undefined</p>
<h3 id="第十一题"><a href="#第十一题" class="headerlink" title="第十一题"></a>第十一题</h3><p>这题跟第五题类似,不赘言</p>
<h3 id="第十二题"><a href="#第十二题" class="headerlink" title="第十二题"></a>第十二题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function f()&#123;</span><br><span class="line">    function f()&#123; return 1; &#125;</span><br><span class="line">    return f();</span><br><span class="line">    function f()&#123; return 2; &#125;</span><br><span class="line">  &#125;)();</span><br></pre></td></tr></table></figure>
<p>这个由于js解析的时候会将声明提前,也就是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function f()&#123;</span><br><span class="line">    function f()&#123; return 1; &#125;</span><br><span class="line">    function f()&#123; return 2; &#125;</span><br><span class="line">    return f();</span><br><span class="line">  &#125;)();</span><br></pre></td></tr></table></figure>
<p>因为函数名相同,会认为重新声明,后面的f()会覆盖前面的f(),所以结果为2 . 关于<code>变量声明提升</code>我前一篇博客里写过了,<a href="http://gaoke700.github.io/2016/01/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%982/" target="_blank" rel="external">点这里去看</a></p>
<h3 id="第十三题"><a href="#第十三题" class="headerlink" title="第十三题"></a>第十三题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123; return f; &#125;</span><br><span class="line">new f() instanceof f;</span><br></pre></td></tr></table></figure>
<p>When <code>new f()</code>  is called,javascript does four things:</p>
<ul>
<li>it creates a new object</li>
<li>it sets the <code> constructor </code>property of the object to<code> f </code></li>
<li>it sets up the object to delegate to<code>   f.prototype </code> </li>
<li>it calls <code> f() </code>in the context of the new object </li>
</ul>
<p>the result of <code> new f() </code> is the new object</p>
<p>补充:构造函数不需要显式声明返回值，默认返回this值。当显式声明了返回值时，如果返回值是非对象（数字、字符串等），这个返回值会被忽略，继续返回this值。但是如果返回值是对象，那么这个显式返回值会被返回。</p>
<p>因为 f() 内部返回了自己，故此时 new f() 的结果和 f 相等。</p>
<h3 id="第十四题"><a href="#第十四题" class="headerlink" title="第十四题"></a>第十四题</h3><pre><code>with (function(x, undefined){}) length;
</code></pre><p>with 限定了作用域是这个函数，function.length 返回函数的参数个数，所以是 2。</p>
<p>undefined 虽然是关键词，但可以被覆写。但 null 不能。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端面试题2]]></title>
      <url>http://yoursite.com/2016/01/04/interview2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>此题由JS的各种坑汇集而成,涉及的知识点包括变量定义提升、this指针指向、运算符优先级、原型、继承、全局变量污染、对象属性及原型属性优先级等等。</p>
<h3 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    getName = function () &#123; alert (1); &#125;;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = function () &#123; alert (2);&#125;;</span><br><span class="line">Foo.prototype.getName = function () &#123; alert (3);&#125;;</span><br><span class="line">var getName = function () &#123; alert (4);&#125;;</span><br><span class="line">function getName() &#123; alert (5);&#125;</span><br><span class="line"></span><br><span class="line">//请写出以下输出结果：</span><br><span class="line">Foo.getName();</span><br><span class="line">getName();</span><br><span class="line">Foo().getName();</span><br><span class="line">getName();</span><br><span class="line">new Foo.getName();</span><br><span class="line">new Foo().getName();</span><br><span class="line">new new Foo().getName();</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="答案是"><a href="#答案是" class="headerlink" title="答案是:"></a>答案是:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foo.getName();//2</span><br><span class="line">getName();//4</span><br><span class="line">Foo().getName();//1</span><br><span class="line">getName();//1</span><br><span class="line">new Foo.getName();//2</span><br><span class="line">new Foo().getName();//3</span><br><span class="line">new new Foo().getName();//3</span><br></pre></td></tr></table></figure>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><hr>
<h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>先看此题的上半部分做了什么，首先定义了一个叫Foo的函数，之后为Foo创建了一个叫getName的静态属性存储了一个匿名函数，之后为Foo的原型对象新创建了一个叫getName的匿名函数。之后又通过函数变量表达式创建了一个getName的函数，最后再声明一个叫getName函数。</p>
<p>第一问的 Foo.getName 自然是访问Foo函数上存储的静态属性，自然是2，没什么可说的。</p>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>第二题，直接调用 getName 函数。既然是直接调用那么就是访问当前上文作用域内的叫getName的函数，所以跟1 2 3都没什么关系。此题有无数面试者回答为5。此处有两个坑，一是变量声明提升，二是函数表达式。</p>
<h4 id="变量声明提升"><a href="#变量声明提升" class="headerlink" title="变量声明提升"></a>变量声明提升</h4><p>即所有声明变量或声明函数都会被提升到当前函数的顶部。</p>
<p>例如下代码:</p>
<pre><code>console.log(&apos;x&apos; in window);//true
var x;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = 0;</span><br></pre></td></tr></table></figure>
<p>代码执行时js引擎会将声明语句提升至代码最上方，变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x;</span><br><span class="line">console.log(&apos;x&apos; in window);//true</span><br><span class="line">x = 0;</span><br></pre></td></tr></table></figure>
<h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><p>var getName 与 function getName 都是声明语句，区别在于 var getName 是函数表达式，而 function getName 是函数声明。关于JS中的各种函数创建方式可以看 <a href="http://www.codeceo.com/article/javascript-closure-interview.html" target="_blank" rel="external">大部分人都会做错的经典JS闭包面试题</a> 这篇文章有详细说明。</p>
<p>函数表达式最大的问题，在于js会将此代码拆分为两行代码分别执行</p>
<p>例如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(x);//输出：function x()&#123;&#125;</span><br><span class="line">var x=1;</span><br><span class="line">function x()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>实际执行的代码为，先将 var x=1 拆分为 var x; 和 x = 1; 两行，再将 var x; 和 function x(){} 两行提升至最上方变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x;</span><br><span class="line">function x()&#123;&#125;</span><br><span class="line">console.log(x);</span><br><span class="line">x=1;</span><br></pre></td></tr></table></figure>
<p>所以最终函数声明的x覆盖了变量声明的x，log输出为x函数。</p>
<p>同理，原题中代码最终执行时的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    getName = function () &#123; alert (1); &#125;;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">var getName;//只提升变量声明</span><br><span class="line">function getName() &#123; alert (5);&#125;//提升函数声明，覆盖var的声明</span><br><span class="line"></span><br><span class="line">Foo.getName = function () &#123; alert (2);&#125;;</span><br><span class="line">Foo.prototype.getName = function () &#123; alert (3);&#125;;</span><br><span class="line">getName = function () &#123; alert (4);&#125;;//最终的赋值再次覆盖function getName声明</span><br><span class="line"></span><br><span class="line">getName();//最终输出4</span><br></pre></td></tr></table></figure>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>第三问的 Foo().getName(); 先执行了Foo函数，然后调用Foo函数的返回值对象的getName属性函数。</p>
<p>Foo函数的第一句  getName = function () { alert (1); };  是一句函数赋值语句，注意它没有var声明，所以先向当前Foo函数作用域内寻找getName变量，没有。再向当前函数作用域上层，即外层作用域内寻找是否含有getName变量，找到了，也就是第二问中的alert(4)函数，将此变量的值赋值为 function(){alert(1)}。</p>
<p>此处实际上是将外层作用域内的getName函数修改了。</p>
<pre><code>注意：此处若依然没有找到会一直向上查找到window对象，若window对象中也没有getName属性，就在window对象中创建一个getName变量。
</code></pre><p>之后Foo函数的返回值是this，而JS的this问题博客园中已经有非常多的文章介绍，这里不再多说。</p>
<p>简单的讲，this的指向是由所在函数的调用方式决定的。而此处的直接调用方式，this指向window对象。</p>
<p>遂Foo函数返回的是window对象，相当于执行 window.getName() ，而window中的getName已经被修改为alert(1)，所以最终会输出1</p>
<p>此处考察了两个知识点，一个是变量作用域问题，一个是this指向问题。</p>
<h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p>直接调用getName函数，相当于 window.getName() ，因为这个变量已经被Foo函数执行时修改了，遂结果与第三问相同，为1</p>
<h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><p>第五问 new Foo.getName(); ,此处考察的是js的运算符优先级问题。</p>
<h4 id="js运算符优先级"><a href="#js运算符优先级" class="headerlink" title="js运算符优先级:"></a>js运算符优先级:</h4><p>通过查上表可以得知点（.）的优先级高于new操作，遂相当于是:</p>
<pre><code>new (Foo.getName)();
</code></pre><p>所以实际上将getName函数作为了构造函数来执行，遂弹出2。</p>
<h3 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h3><p>第六问 new Foo().getName() ，首先看运算符优先级括号高于new，实际执行为</p>
<pre><code>(new Foo()).getName()
</code></pre><p>遂先执行Foo函数，而Foo此时作为构造函数却有返回值，所以这里需要说明下js中的构造函数返回值问题。</p>
<h4 id="构造函数的返回值"><a href="#构造函数的返回值" class="headerlink" title="构造函数的返回值"></a>构造函数的返回值</h4><p>在传统语言中，构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象。</p>
<p>而在js中构造函数可以有返回值也可以没有。</p>
<p>1、没有返回值则按照其他语言一样返回实例化对象。</p>
<pre><code>function fn(){}
undefined
new fn()
fn{}
</code></pre><p>2、若有返回值则检查其返回值是否为引用类型。如果是非引用类型，如基本类型（string,number,boolean,null,undefined）则与无返回值相同，实际返回其实例化对象。</p>
<pre><code>function fn(){ return true }
undefined
new fn()
fn{}
</code></pre><p>3、若返回值是引用类型，则实际返回值为这个引用类型。</p>
<pre><code>function fn(){ return {a:1}; }
undefined
new fn()
Object {a:1}
</code></pre><p>原题中，返回的是this，而this在构造函数中本来就代表当前实例化对象，遂最终Foo函数返回实例化对象。</p>
<p>之后调用实例化对象的getName函数，因为在Foo构造函数中没有为实例化对象添加任何属性，遂到当前对象的原型对象（prototype）中寻找getName，找到了。遂最终输出3。</p>
<h3 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h3><p>第七问, new new Foo().getName(); 同样是运算符优先级问题。</p>
<p>最终实际执行为：</p>
<pre><code>new ((new Foo()).getName)();
</code></pre><p>先初始化Foo的实例化对象，然后将其原型上的getName函数作为构造函数再次new。遂最终结果为3</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS中typeof与instanceof的区别]]></title>
      <url>http://yoursite.com/2015/12/24/typeof/</url>
      <content type="html"><![CDATA[<p>JavaScript 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的。但它们之间还是有区别的：</p>
<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>它是一个一元运算，放在一个运算数之前，运算数可以是任意类型</p>
<p>它返回值是一个字符串，该字符串说明运算数的类型。typeof 一般只能返回如下几个结果：</p>
<pre><code>number,boolean,string,function,object,undefined。
</code></pre><a id="more"></a>
<p>我们可以使用 typeof 来获取一个变量是否存在，如 </p>
<pre><code>if(typeof a!=&quot;undefined&quot;){alert(&quot;ok&quot;)}
</code></pre><p>而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错，对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。</p>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>instanceof 用于判断一个变量是否某个对象的实例</p>
<pre><code>a instanceof b?alert(&quot;true&quot;):alert(&quot;false&quot;); //a是b的实例？真:假
</code></pre><p>如 </p>
<pre><code>var a=new Array();
alert(a instanceof Array);         //会返回 true
alert(a instanceof Object)         //也会返回 true;这是因为 Array 是 object 的子类
</code></pre><p>再如:</p>
<pre><code>function test(){};
var a=new test();
alert(a instanceof test)    //返回true
</code></pre><p>注1:</p>
<p>谈到 instanceof 我们要多插入一个问题，就是 function 的 arguments，我们大家也许都认为 arguments 是一个 Array，但如果使用 instaceof 去测试会发现 arguments 不是一个 Array 对象，尽管看起来很像。</p>
<p>注2:</p>
<pre><code>var a=new Array();
if (a instanceof Object){ alert(&apos;Y&apos;);}
else alert(&apos;N&apos;);     //弹出Y
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端面试题1]]></title>
      <url>http://yoursite.com/2015/12/06/interview1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>前端还是一个年轻的行业，新的行业标准， 框架， 库都不断在更新和新增，正如赫门在2015深JS大会上的《前端服务化之路》主题演讲中说的一句话：“每18至24个月，前端都会难一倍”，这些变化使前端的能力更加丰富、创造的应用也会更加完美。所以关注各种前端技术，跟上快速变化的节奏，也是身为一个前端程序员必备的技能之一。<br><a id="more"></a><br>面试有几点需注意：(来源寒冬winter 老师，github:@wintercn)</p>
<ul>
<li><p>面试题目： 根据你的等级和职位的变化，入门级到专家级，广度和深度都会有所增加。</p>
</li>
<li><p>题目类型： 理论知识、算法、项目细节、技术视野、开放性题、工作案例。</p>
</li>
<li><p>细节追问： 可以确保问到你开始不懂或面试官开始不懂为止，这样可以大大延展题目的区分度和深度，知道你的实际能力。因为这种知识关联是长时期的学习，临时抱佛脚绝对是记不住的。</p>
</li>
<li><p>回答问题再棒，面试官（可能是你面试职位的直接领导），会考虑我要不要这个人做我的同事？所以态度很重要、除了能做事，还要会做人。（感觉更像是相亲( •̣̣̣̣̣̥́௰•̣̣̣̣̣̥̀ )）</p>
</li>
<li><p>资深的前端开发能把absolute和relative弄混，这样的人不要也罢，因为团队需要的是：你这个人具有可以依靠的才能（靠谱）。</p>
</li>
</ul>
<p>前端开发知识点：</p>
<pre><code>HTML&amp;CSS：
        对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、
    HTML5、CSS3、Flexbox

JavaScript：
    数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、
    DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 6、Nodejs

其他：
    移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力
</code></pre><p>作为一名前端工程师，无论工作年头长短都应该掌握的知识点：</p>
<p>此条由 王子墨 发表在 <a href="http://lab.yuanwai.wang/" target="_blank" rel="external">攻城师的实验室</a></p>
<pre><code>1、DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。

2、DOM操作 ——如何添加、移除、移动、复制、创建和查找节点等。

3、事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。

4、XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。

5、严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。

6、盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型

7、块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们

8、浮动元素 ——怎么使用它们、它们有什么问题以及怎么解决这些问题。

9、HTML与XHTML ——二者有什么区别，你觉得应该使用哪一个并说出理由。

10、JSON —— 作用、用途、设计结构。
</code></pre><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><hr>
<ul>
<li><p>Doctype作用？严格模式与混杂模式如何区分？它们有何意义?</p>
</li>
<li><p>HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？</p>
</li>
<li><p>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</p>
</li>
<li><p>页面导入样式时，使用link和@import有什么区别？</p>
</li>
<li><p>介绍一下你对浏览器内核的理解？</p>
</li>
<li><p>常见的浏览器内核有哪些？</p>
</li>
<li><p>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</p>
</li>
<li><p>简述一下你对HTML语义化的理解？</p>
</li>
<li><p>HTML5的离线储存怎么使用，工作原理能不能解释一下？</p>
</li>
<li><p>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</p>
</li>
<li><p>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</p>
</li>
<li><p>iframe有那些缺点？</p>
</li>
<li><p>Label的作用是什么？是怎么用的？（加 for 或 包裹）</p>
</li>
<li><p>HTML5的form如何关闭自动完成功能？</p>
</li>
<li><p>如何实现浏览器内多个标签页之间的通信? (阿里)</p>
</li>
<li><p>webSocket如何兼容低浏览器？(阿里)</p>
</li>
<li><p>页面可见性（Page Visibility API） 可以有哪些用途？</p>
</li>
<li><p>如何在页面上实现一个圆形的可点击区域？</p>
</li>
<li><p>实现不使用 border 画出1px高的线，在不同浏览器的Quirksmode和CSSCompat模式下都能保持同一效果。</p>
</li>
<li><p>网页验证码是干嘛的，是为了解决什么安全问题？</p>
</li>
<li><p>title与h1的区别、b与strong的区别、i与em的区别？</p>
</li>
</ul>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><hr>
<ul>
<li><p>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</p>
</li>
<li><p>CSS选择符有哪些？哪些属性可以继承？</p>
</li>
<li><p>CSS优先级算法如何计算？</p>
</li>
<li><p>CSS3新增伪类有那些？</p>
</li>
<li><p>如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</p>
</li>
<li><p>display有哪些值？说明他们的作用。</p>
</li>
<li><p>position的值relative和absolute定位原点是？</p>
</li>
<li><p>CSS3有哪些新特性？</p>
</li>
<li><p>请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</p>
</li>
<li><p>用纯CSS创建一个三角形的原理是什么？</p>
</li>
<li><p>一个满屏 品 字布局 如何设计?</p>
</li>
<li><p>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</p>
</li>
<li><p>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</p>
</li>
<li><p>为什么要初始化CSS样式?</p>
</li>
<li><p>absolute的containing block计算方式跟正常流有什么不同？</p>
</li>
<li><p>CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？</p>
</li>
<li><p>position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？</p>
</li>
<li><p>对BFC规范(块级格式化上下文：block formatting context)的理解？</p>
</li>
<li><p>CSS权重优先级是如何计算的？</p>
</li>
<li><p>请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式</p>
</li>
<li><p>移动端的布局用过媒体查询吗？</p>
</li>
<li><p>使用 CSS 预处理器吗？喜欢那个？</p>
</li>
<li><p>CSS优化、提高性能的方法有哪些？</p>
</li>
<li><p>浏览器是怎样解析CSS选择器的？</p>
</li>
<li><p>在网页中的应该使用奇数还是偶数的字体？为什么呢？</p>
</li>
<li><p>margin和padding分别适合什么场景使用？</p>
</li>
<li><p>抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]</p>
</li>
<li><p>元素竖向的百分比设定是相对于容器的高度吗？</p>
</li>
<li><p>全屏滚动的原理是什么？用到了CSS的那些属性？</p>
</li>
<li><p>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</p>
</li>
<li><p>视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）</p>
</li>
<li><p>::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。</p>
</li>
<li><p>如何修改chrome记住密码后自动填充表单的黄色背景 ？</p>
</li>
<li><p>你对line-height是如何理解的？</p>
</li>
<li><p>设置元素浮动后，该元素的display值是多少？（自动变成display:block）</p>
</li>
<li><p>怎么让Chrome支持小于12px 的文字？</p>
</li>
<li><p>让页面里的字体变清晰，变细用CSS怎么做？（-webkit-font-smoothing: antialiased;）</p>
</li>
<li><p>font-style属性可以让它赋值为“oblique” oblique是什么意思？</p>
</li>
<li><p>position:fixed;在android下无效怎么处理？</p>
</li>
<li><p>如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</p>
</li>
<li><p>display:inline-block 什么时候会显示间隙？(携程)</p>
</li>
<li><p>overflow: scroll时不能平滑滚动的问题怎么处理？</p>
</li>
<li><p>有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。</p>
</li>
<li><p>png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？</p>
</li>
<li><p>什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）</p>
</li>
<li><p>style标签写在body后与body前有什么区别？</p>
</li>
<li><p>什么是CSS 预处理器 / 后处理器？</p>
</li>
</ul>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><hr>
<ul>
<li><p>介绍JavaScript的基本数据类型。</p>
</li>
<li><p>说说写JavaScript的基本规范？</p>
</li>
<li><p>JavaScript原型，原型链 ? 有什么特点？</p>
</li>
<li><p>JavaScript有几种类型的值？（堆：原始数据类型和 栈：引用数据类型），你能画一下他们的内存图吗？</p>
</li>
<li><p>Javascript如何实现继承？</p>
</li>
<li><p>Javascript创建对象的几种方式？</p>
</li>
<li><p>Javascript作用链域?</p>
</li>
<li><p>谈谈this对象的理解。</p>
</li>
<li><p>eval是做什么的？</p>
</li>
<li><p>什么是window对象? 什么是document对象?</p>
</li>
<li><p>null，undefined的区别？</p>
</li>
<li><p>写一个通用的事件侦听器函数(机试题)。</p>
</li>
<li><p>[“1”, “2”, “3”].map(parseInt) 答案是多少？</p>
</li>
<li><p>关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</p>
</li>
<li><p>什么是闭包（closure），为什么要用它？</p>
</li>
<li><p>javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</p>
</li>
<li><p>如何判断一个对象是否属于某个类？</p>
</li>
<li><p>new操作符具体干了什么呢?</p>
</li>
<li><p>用原生JavaScript的实现过什么功能吗？</p>
</li>
<li><p>Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</p>
</li>
<li><p>对JSON的了解？</p>
</li>
<li><p>[].forEach.call($$(“<em>“),function(a){ a.style.outline=”1px solid #”+(~~(Math.random()</em>(1&lt;&lt;24))).toString(16) }) 能解释一下这段代码的意思吗？</p>
</li>
<li><p>js延迟加载的方式有哪些？</p>
</li>
<li><p>Ajax 是什么? 如何创建一个Ajax？</p>
</li>
<li><p>同步和异步的区别?</p>
</li>
<li><p>如何解决跨域问题?</p>
</li>
<li><p>页面编码和被请求的资源编码如果不一致如何处理？</p>
</li>
<li><p>模块化开发怎么做？</p>
</li>
<li><p>AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</p>
</li>
<li><p>requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</p>
</li>
<li><p>谈一谈你对ECMAScript6的了解？</p>
</li>
<li><p>ECMAScript6 怎么写class，为什么会出现class这种东西?</p>
</li>
<li><p>异步加载的方式有哪些？</p>
</li>
<li><p>documen.write和 innerHTML的区别?</p>
</li>
<li><p>DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</p>
</li>
<li><p>.call() 和 .apply() 的作用和区别？</p>
</li>
<li><p>数组和对象有哪些原生方法，列举一下？</p>
</li>
<li><p>JS 怎么实现一个类。怎么实例化这个类</p>
</li>
<li><p>JavaScript中的作用域与变量声明提升？</p>
</li>
<li><p>如何编写高性能的Javascript？</p>
</li>
<li><p>那些操作会造成内存泄漏？</p>
</li>
<li><p>JQuery的源码看过吗？能不能简单概况一下它的实现原理？</p>
</li>
<li><p>jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？</p>
</li>
<li><p>jquery中如何将数组转化为json字符串，然后再转化回来？</p>
</li>
<li><p>jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？</p>
</li>
<li><p>jquery.extend 与 jquery.fn.extend的区别？</p>
</li>
<li><p>jQuery 的队列是如何实现的？队列可以用在哪些地方？</p>
</li>
<li><p>谈一下Jquery中的bind(),live(),delegate(),on()的区别？</p>
</li>
<li><p>JQuery一个对象可以同时绑定多个事件，这是如何实现的？</p>
</li>
<li><p>是否知道自定义事件。jQuery里的fire函数是什么意思，什么时候用？</p>
</li>
<li><p>jQuery 是通过哪个方法和 Sizzle 选择器结合的？（jQuery.fn.find()进入Sizzle）</p>
</li>
<li><p>针对 jQuery性能的优化方法？</p>
</li>
<li><p>Jquery与jQuery UI有啥区别？</p>
</li>
<li><p>JQuery的源码看过吗？能不能简单说一下它的实现原理？</p>
</li>
<li><p>jquery 中如何将数组转化为json字符串，然后再转化回来？</p>
</li>
<li><p>jQuery和Zepto的区别？各自的使用场景？</p>
</li>
<li><p>针对 jQuery 的优化方法？</p>
</li>
<li><p>Zepto的点透问题如何解决？</p>
</li>
<li><p>jQueryUI如何自定义组件?</p>
</li>
<li><p>需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</p>
</li>
<li><p>如何判断当前脚本运行在浏览器还是node环境中？（阿里）</p>
</li>
<li><p>移动端最小触控区域是多大？</p>
</li>
<li><p>jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?</p>
</li>
<li><p>把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？</p>
</li>
<li><p>移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？（click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。）</p>
</li>
<li><p>知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout…)么? 能讲出他们各自的优点和缺点么?</p>
</li>
<li><p>Underscore 对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？</p>
</li>
<li><p>解释JavaScript中的作用域与变量声明提升？</p>
</li>
<li><p>那些操作会造成内存泄漏？</p>
</li>
<li><p>JQuery一个对象可以同时绑定多个事件，这是如何实现的？</p>
</li>
<li><p>Node.js的适用场景？</p>
</li>
<li><p>(如果会用node)知道route, middleware, cluster, nodemon, pm2, server-side rendering么?</p>
</li>
<li><p>解释一下 Backbone 的 MVC 实现方式？</p>
</li>
<li><p>什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?</p>
</li>
<li><p>知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?</p>
</li>
<li><p>如何测试前端代码么? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)?</p>
</li>
<li><p>前端templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?</p>
</li>
<li><p>简述一下 Handlebars 的基本用法？</p>
</li>
<li><p>简述一下 Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？</p>
</li>
<li><p>用js实现千位分隔符?(来源：前端农民工，提示：正则+replace)</p>
</li>
<li><p>检测浏览器版本版本有哪些方式？</p>
</li>
<li><p>What is a Polyfill?</p>
</li>
<li><p>做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？</p>
</li>
<li><p>我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？</p>
</li>
</ul>
<h3 id="ECMAScript6-相关"><a href="#ECMAScript6-相关" class="headerlink" title="ECMAScript6 相关"></a>ECMAScript6 相关</h3><ul>
<li>Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？</li>
</ul>
<h3 id="前端框架相关"><a href="#前端框架相关" class="headerlink" title="前端框架相关"></a>前端框架相关</h3><ul>
<li><p>react-router 路由系统的实现原理？</p>
</li>
<li><p>React中如何解决第三方类库的问题?</p>
</li>
</ul>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><hr>
<ul>
<li><p>原来公司工作流程是怎么样的，如何与其他人协作的？如何夸部门合作的？</p>
</li>
<li><p>你遇到过比较难的技术问题是？你是如何解决的？</p>
</li>
<li><p>设计模式 知道什么是singleton, factory, strategy, decrator么?</p>
</li>
<li><p>常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？</p>
</li>
<li><p>页面重构怎么操作？</p>
</li>
<li><p>列举IE与其他浏览器不一样的特性？</p>
</li>
<li><p>99%的网站都需要被重构是那本书上写的？</p>
</li>
<li><p>什么叫优雅降级和渐进增强？</p>
</li>
<li><p>是否了解公钥加密和私钥加密。</p>
</li>
<li><p>WEB应用从服务器主动推送Data到客户端有那些方式？</p>
</li>
<li><p>对Node的优点和缺点提出了自己的看法？</p>
</li>
<li><p>你有用过哪些前端性能优化的方法？</p>
</li>
<li><p>http状态码有那些？分别代表是什么意思？</p>
</li>
<li><p>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</p>
</li>
<li><p>部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？</p>
</li>
<li><p>从打开app到刷新出内容，整个过程中都发生了什么，如果感觉慢，怎么定位问题，怎么解决?</p>
</li>
<li><p>除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？</p>
</li>
<li><p>你用的得心应手用的熟练地编辑器&amp;开发环境是什么样子？</p>
</li>
<li><p>对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</p>
</li>
<li><p>你怎么看待Web App 、hybrid App、Native App？</p>
</li>
<li><p>你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？）</p>
</li>
<li><p>你对加班的看法？</p>
</li>
<li><p>平时如何管理你的项目？</p>
</li>
<li><p>说说最近最流行的一些东西吧？常去哪些网站？</p>
</li>
<li><p>如何设计突发大规模并发架构？</p>
</li>
<li><p>说说最近最流行的一些东西吧？常去哪些网站？</p>
</li>
<li><p>是否了解开源的工具 bower、npm、yeoman、grunt、gulp，一个 npm 的包里的 package.json 具备的必要的字段都有哪些？（名称、版本号，依赖）</p>
</li>
<li><p>每个模块的代码结构都应该比较简单，且每个模块之间的关系也应该非常清晰，随着功能和迭代次数越来越多，你会如何去保持这个状态的？</p>
</li>
<li><p>Git知道branch, diff, merge么?</p>
</li>
<li><p>如何设计突发大规模并发架构？</p>
</li>
<li><p>当团队人手不足，把功能代码写完已经需要加班的情况下，你会做前端代码的测试吗？</p>
</li>
<li><p>说说最近最流行的一些东西吧？平时常去哪些网站？</p>
</li>
<li><p>知道什么是SEO并且怎么优化么? 知道各种meta data的含义么?</p>
</li>
<li><p>移动端（Android IOS）怎么做好用户体验?</p>
</li>
<li><p>简单描述一下你做过的移动APP项目研发流程？</p>
</li>
<li><p>你在现在的团队处于什么样的角色，起到了什么明显的作用？</p>
</li>
<li><p>你认为怎样才是全端工程师（Full Stack developer）？</p>
</li>
<li><p>介绍一个你最得意的作品吧？</p>
</li>
<li><p>你有自己的技术博客吗，用了哪些技术？</p>
</li>
<li><p>对前端安全有什么看法？</p>
</li>
<li><p>是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？</p>
</li>
<li><p>项目中遇到国哪些印象深刻的技术难题，具体是什么问题，怎么解决？。</p>
</li>
<li><p>最近在学什么东西？</p>
</li>
<li><p>你的优点是什么？缺点是什么？</p>
</li>
<li><p>如何管理前端团队?</p>
</li>
<li><p>最近在学什么？能谈谈你未来3，5年给自己的规划吗？</p>
</li>
</ul>
<h3 id="有趣的问题"><a href="#有趣的问题" class="headerlink" title="有趣的问题"></a>有趣的问题</h3><hr>
<ul>
<li><p>A、B两人分别在两座岛上。B生病了，A有B所需要的药。C有一艘小船和一个可以上锁的箱子。C愿意在A和B之间运东西，但东西只能放在箱子里。只要箱子没被上锁，C都会偷走箱子里的东西，不管箱子里有什么。如果A和B各自有一把锁和只能开自己那把锁的钥匙，A应该如何把东西安全递交给B？</p>
<pre><code>答案：A把药放进箱子，用自己的锁把箱子锁上。B拿到箱子后，再在箱子上加一把自己的锁。
箱子运回A后，A取下自己的锁。箱子再运到B手中时，B取下自己的锁，获得药物。
</code></pre></li>
<li><p>Amazon主页的左上角有一个商品分类浏览的下拉菜单 没有延迟，而且子菜单也不会在不应该的时候消失。它是怎样做到这一点的呢？</p>
<pre><code>答案是通过探测鼠标移动的方向和轨迹，具体查看Khan Academy工程师 Ben Kamens 写的 jQuery插件
</code></pre></li>
</ul>
<h2 id="相关答案"><a href="#相关答案" class="headerlink" title="相关答案"></a>相关答案</h2><hr>
<p><a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers" target="_blank" rel="external">偷看答案</a></p>
<h2 id="前端学习网站推荐"><a href="#前端学习网站推荐" class="headerlink" title="前端学习网站推荐"></a>前端学习网站推荐</h2><hr>
<pre><code>1. 极客标签：     http://www.gbtags.com/

2. 码农周刊：     http://weekly.manong.io/issues/

3. 前端周刊：     http://www.feweekly.com/issues

4. 慕课网：       http://www.imooc.com/

5. div.io：         http://div.io

6. Hacker News： https://news.ycombinator.com/news

7. InfoQ：       http://www.infoq.com/

8. w3cplus：     http://www.w3cplus.com/

9. Stack Overflow： http://stackoverflow.com/

10.w3school：    http://www.w3school.com.cn/

11.mozilla：     https://developer.mozilla.org/zh-CN/docs/Web/
</code></pre><h2 id="文档推荐"><a href="#文档推荐" class="headerlink" title="文档推荐"></a>文档推荐</h2><hr>
<ul>
<li><p><a href="http://docs.huihoo.com/jquery/jquery-fundamentals/zh-cn/index.html" target="_blank" rel="external">jQuery 基本原理</a></p>
</li>
<li><p><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/" target="_blank" rel="external">JavaScript 秘密花园</a></p>
</li>
<li><p><a href="http://css.doyoe.com/" target="_blank" rel="external">CSS参考手册</a></p>
</li>
<li><p><a href="http://javascript.ruanyifeng.com/" target="_blank" rel="external">JavaScript 标准参考教程</a></p>
</li>
<li><p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6入门</a></p>
</li>
</ul>
<p>本文引自<a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Question" target="_blank" rel="external">https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Question</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jade的使用]]></title>
      <url>http://yoursite.com/2015/11/17/useJade/</url>
      <content type="html"><![CDATA[<p>Jade是一个基于javascript，可以运行与node与浏览器环境的一个前端模板引擎</p>
<h2 id="tag标签"><a href="#tag标签" class="headerlink" title="tag标签"></a>tag标签</h2><p>通过缩进关系，代替以往html的层级包含关系，如一个简单的静态页面可以表达为<br><img src="http://fs.powereasy.net/summarize/2015/11/201511032309283997.png" alt=""><br><a id="more"></a><br>内联书写层级<br>   a: img<br>   通过分号区分元素内内容<br>自闭合标签<br>   img、meta、link 等自闭合会自动识别<br>可通过在标签后添加” / “强制输出自闭合元素<br><img src="http://fs.powereasy.net/summarize/2015/11/201511032309514383.png" alt=""><br>style属性<br>style属性可以想上面的格式传入一个文本包含所有样式内容，或者传入一个类似js中的对象，达到同样的效果<br><img src="http://fs.powereasy.net/summarize/2015/11/201511032310010255.png" alt=""></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>使用” = “号输出变量值到元素内<br><img src="http://fs.powereasy.net/summarize/2015/11/201511032310126718.png" alt=""><br>通过 #{variable} 插入相应的变量值<br><img src="http://fs.powereasy.net/summarize/2015/11/201511032310227714.png" alt=""></p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>html 元素属性通过在标签右边通过括号包含（此处逗号可拆分为多行书写属性的格式）<br><img src="http://fs.powereasy.net/summarize/2015/11/201511032310322591.png" alt=""><br>也支持表达式进行属性的判断：<br><img src="http://fs.powereasy.net/summarize/2015/11/201511032310425785.png" alt=""><br>如果是布尔型的属性，jade会自动根据当前doctype输出适合的格式，对比如下：</p>
<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><ul>
<li>通过在文字前面添加竖线符号” | “可让 jade 原样输出内容</li>
<li>在html标签标记后面通过空格隔开文本内容</li>
<li>在html标签标记后通过添加英文句号” . “添加块级文本<br>上面3个形式的方式效果为：<br><img src="http://fs.powereasy.net/summarize/2015/11/201511032310547794.png" alt=""><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2>可以通过双斜杠进行注释，jade有3种注释方式，可以分别对应输出html注释、不输出html注释、块级html注释，如图：<br><img src="http://fs.powereasy.net/summarize/2015/11/201511032311031332.png" alt=""><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2>jade支持通过js语法形式运行一些表达式，最简单常用的就一个迭代可以表达为：<br><img src="http://fs.powereasy.net/summarize/2015/11/201511032311125828.png" alt=""><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2>jade 支持 if 、case条件判断，类比js的相应语法：<br><img src="http://fs.powereasy.net/summarize/2015/11/201511032311213244.png" alt=""><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2>支持其他不同语法的代码插入。(需要安装有相应的包）<br>比如我们可以在一个段落下插入一段markdown文本：<br><img src="http://fs.powereasy.net/summarize/2015/11/201511032311294998.png" alt=""><h2 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h2>如果我们以前有接触过sass等预编译样式语言的话，也就理解了这个的用法，方法十分类似，通过定义部分可以公用的代码之后，适当的设置可传入参数，可以实现代码大程度上的复用。<br>定义和使用的语法也比较简单：<br><img src="http://fs.powereasy.net/summarize/2015/11/201511032311381267.png" alt=""><br><a href="http://jade-lang.com/reference/mixins/" target="_blank" rel="external">http://jade-lang.com/reference/mixins/</a><br>可以参考官方说明文档，重点可以着重理解最后2种调用方式。<h2 id="Extends"><a href="#Extends" class="headerlink" title="Extends"></a>Extends</h2>layout.jade 文件:<br><img src="http://fs.powereasy.net/summarize/2015/11/201511032321530427.png" alt=""><br>index.jade 文件:<br><img src="http://fs.powereasy.net/summarize/2015/11/201511032322046531.png" alt=""><br>默认继承方式为覆盖原内容，还可选 <code>prepend</code> 在代码前插入， <code>append</code> 在代码后插入，<br><img src="http://fs.powereasy.net/summarize/2015/11/201511032322156104.png" alt="">“/&gt;<br>可以省略 <code>block</code> 写为：<br><img src="http://fs.powereasy.net/summarize/2015/11/201511032322224643.png" alt=""><h2 id="Include"><a href="#Include" class="headerlink" title="Include"></a>Include</h2><strong>index.jade 文件</strong><br><img src="http://fs.powereasy.net/summarize/2015/11/201511032322319735.png" alt=""><br><strong>head.jade 文件</strong><br><img alt="" src="http://fs.powereasy.net/summarize/2015/11/201511032322393385.png"><br><strong>包含文件</strong><br><img alt="" src="http://fs.powereasy.net/summarize/2015/11/201511032323021595.png"></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jade的基础语法]]></title>
      <url>http://yoursite.com/2015/11/17/jadeGrammar/</url>
      <content type="html"><![CDATA[<p>如果你熟悉 Sublime Text 和 Emmet 的组合，那么 Jade 也会是你的菜。<code>模板引擎</code>这个术语听起来太过于高大上了，私下里我更喜欢称它们是 HTML 预处理语言，非常类似 Sass 之于 CSS —— 不过相比起 Sass 操纵 CSS 的强大力量，Jade 对 HTML 的影响只能说本本分分，没有什么激进之处，当然，这并不是坏事。</p>
<p>Jade 中省略了大量的尖括号，给我的感觉就是简洁和高效。这里不会讨论各种模板引擎的优劣，技术和工具的好坏向来都是不死不休的伪命题，还是花更多的时间来创造有价值的东西更有意思。</p>
<p>本文主要参考了 <a href="http://jade-lang.com/reference/" target="_blank" rel="external">Jade 官方的英文文档</a>，并根据自己的经验缩减了部分内容——求全求精不是本文的目的，希望本文能够让你快速入门。即使做了部分精简，掌握之后也可以应对百分之九十以上的需求。此外，官方文档的各个小节是按字典序排列的，这并不适合第一次接触 Jade 的开发者，所以你懂得，我又给它改了……</p>
<p>古语有云：工欲善其事，必先利其器。利用 npm 安装 Jade 的过程这里就不介绍了，一方面是因为 mac 下安装太简单；另一方面是因为 windows 下给了我太多阴影……所以，这里直接附上<a href="http://naltatis.github.io/jade-syntax-docs/" target="_blank" rel="external">在线测试页面</a>，即开即用。<br><a id="more"></a></p>
<h2 id="Doctype"><a href="#Doctype" class="headerlink" title="Doctype"></a>Doctype</h2><p>那年，某位学长来介绍 HTML 入门，上来第一个操作就是复制了这么一串，复制了这么一串……</p>
<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&gt;
</code></pre><p>幸好现在是 HTML5 流行的新时代，文档类型精简掉了那个冗长拖沓的尾巴，即使手工编写也不费劲：</p>
<pre><code>&lt;!DOCTYPE html&gt;
</code></pre><p>Jade 对此做的更彻底：不用尖括号，不用大小写……</p>
<pre><code>doctype html
</code></pre><p>其他常用类型还有：</p>
<ul>
<li><code>doctype xml</code></li>
<li><code>doctype transitional</code></li>
<li><code>doctype strict</code></li>
<li>自定义文档类型以及其他类型，可以<a href="http://jade-lang.com/reference/doctype/" target="_blank" rel="external">参考这里</a>。</li>
</ul>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>标签是 HTML 的核心元素，所以我们就从这里入手。不知道大家有没有接触过 python，如果接触过，那下面就很好理解了；如果没接触过，那么就需要培养一种意识——缩进意识。Jade 和 python 都是对缩进敏感的语法形式。在其他语言中，缩进可能是一种表面功夫，是用来提高可读性的，但在 jade 和 pyhton 中还兼具划分层次结构的作用。这种强制缩进的好处是提高了可读性，省略了一些界定符号（大括号、尖括号……）。</p>
<p>在 Jade 中创建一个列表：</p>
<pre><code>ul
  li Item A
  li Item B
  li Item C
</code></pre>

<p>生成的 HTML：</p>
<pre><code>&lt;ul&gt;
  &lt;li&gt;Item A&lt;/li&gt;
  &lt;li&gt;Item B&lt;/li&gt;
  &lt;li&gt;Item C&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>就是这么简单，再也不用顾虑<code>标签闭合了吗</code>、<code>shift 键在哪啊</code>，全程无压力高速输出！唯一需要记住的就是用统一的缩进来嵌套标签。</p>
<p>虽然 jade 还提供了另一种嵌套形式，但这里并不推荐。此外，jade 还有关于自闭和标签（<code>img</code> 等）的介绍，这里也不作介绍。之所以精简掉它们，主要是避免用法混乱导致的错误。建议使用上述创建列表的方法创建其他标签。有关标签的更多信息，请<a href="http://jade-lang.com/reference/tags/" target="_blank" rel="external">参考这里</a>。</p>

<blockquote><br>  <p>提示：如果环境已经正确安装，那么大多数情况下的错误都是缩进惹的祸，一定一定要保持一致的缩进格式，建议统一将 <code>tab</code> 键输出为空格，并采用 4 个空格作为标准缩进。</p><br></blockquote>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Jade 支持两种注释：单行注释和多行注释。每种注释支持两种模式：输出到源文件和不输出到源文件。</p>

<p>在 Jade 中创建一个单行输出注释和单行不输出注释：</p>

<pre><code>// 这个单行注释会输出到编译后的文件中
p 单行输出注释
//- 这个单行注释不会输出到编译后的文件中
p 单行不输出注释
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;!-- 这个单行注释会输出到编译后的文件中--&gt;
&lt;p&gt;单行输出注释&lt;/p&gt;
&lt;p&gt;单行不输出注释&lt;/p&gt;
</code></pre>

<p>由上可见，输出和不输出的差别就在于多了一个 <code>-</code>，谨记！</p>

<p>相比起单行注释，多行注释的内容要在注释符号的下一行，以相同的缩进来编写。多行注释的输出和不输出模式和单行注释相同，需要使用 <code>-</code> 标记：</p>

<pre><code>// 
    这个多行注释会输出到编译后的文件中
    这个多行注释会输出到编译后的文件中
p 多行输出注释
//- 
    这个多行注释不会输出到编译后的文件中
    这个多行注释不会输出到编译后的文件中
p 多行不输出注释
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;!-- 
这个多行注释会输出到编译后的文件中
这个多行注释会输出到编译后的文件中
--&gt;
&lt;p&gt;多行输出注释&lt;/p&gt;
&lt;p&gt;多行不输出注释&lt;/p&gt;
</code></pre>

<p>有关注释的更多信息，可以<a href="http://jade-lang.com/reference/comments/" target="_blank" rel="external">参考这里</a>。</p>

<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>在 Jade 中填写属性，基本上和 HTML 保持了一致：</p>

<pre><code>input(type='checkbox', checked)
input(
  type='checkbox'
  name='agreement'
  checked
)
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;input type="checkbox" checked&gt;
&lt;input type="checkbox" name="agreement" checked&gt;
</code></pre>

<p>但是，你见过可以根据条件设置属性的语法形式吗？这里就有：</p>

<pre><code>- var authenticated = true
body(class=authenticated ? 'authed' : 'anon')
- var currentUrl = '/about'
a(class={active: currentUrl === '/'} href='/') Home
a(class={active: currentUrl === '/about'} href='/about') About
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;body class="authed"&gt;&lt;/body&gt;
&lt;a href="/"&gt;Home&lt;/a&gt;&lt;a href="/about" class="active"&gt;
</code></pre>

<p>对于频繁使用到的类名和 ID 名，Jade 提供了两种字面量：类名字面量和 ID 字面量——非常类似 Emmet 的用法。如果不在字面量前边指定标签名，则默认使用 <code>div</code>:</p>

<pre><code>.link
a.link
#button
a#button
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;div class="link"&gt;&lt;/div&gt;
&lt;a class="link"&gt;&lt;/a&gt;
&lt;div id="button"&gt;&lt;/div&gt;
&lt;a id="button"&gt;&lt;/a&gt;
</code></pre>

<p>另一个常常会被 JavaScript 修改的属性就是 <code>style</code>。为了更方便地修改该属性，Jade 接收一个类似 JavaScript 对象类型的参数：</p>

<pre><code>a(style={color: 'red', background: 'green'})
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;a style="color:red;background:green"&gt;&lt;/a&gt;
</code></pre>

<p>为了更方便地添加其他自定义属性，jade 特意增加了一个语法格式 <code>&amp;attributes</code>：</p>

<pre><code>- var attributes = {'data-foo': 'bar'};
div#foo(data-bar="foo")&amp;attributes(attributes)
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;div id="foo" data-bar="foo" data-foo="bar"&gt;&lt;/div&gt;
</code></pre>

<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><p>Jade 支持三种文本输出方式：单行文本、管道文本和多行文本：</p>

<pre><code>// 单行文本内容直接跟在标签名后面
p 这里是单行文本内容
// 管道文本使用管道符
p 
    | 这是一行管道文本，行数无限制
    | 这是一行管道文本，行数无限制
    | 这是一行管道文本，行数无限制
    | ……
// 多行文本需要在标签名后添加点号
p.
    这是多行文本，注意缩进
    这是多行文本，注意缩进
    这是多行文本，注意缩进
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;!-- 单行文本内容直接跟在标签名后面--&gt;
&lt;p&gt;这里是单行文本内容&lt;/p&gt;
&lt;!-- 管道文本使用管道符--&gt;
&lt;p&gt;
  这是一行管道文本，行数无限制
  这是一行管道文本，行数无限制
  这是一行管道文本，行数无限制
  ……
&lt;/p&gt;
&lt;!-- 多行文本需要在标签名后添加点号--&gt;
&lt;p&gt;
  这是多行文本，注意缩进
  这是多行文本，注意缩进
  这是多行文本，注意缩进
&lt;/p&gt;
</code></pre>

<h2 id="代码嵌入"><a href="#代码嵌入" class="headerlink" title="代码嵌入"></a>代码嵌入</h2><p>将 JavaScript 嵌入到 Jade 中，一共有三种方法。第一种方式是使用 <code>-</code>，代码中的特殊字符不会被转义：</p>

<pre><code>- for (var x = 0; x &lt; 3; x++)
  li &lt;a&gt;&lt;/a&gt;
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;li&gt;&lt;a&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a&gt;&lt;/a&gt;&lt;/li&gt;
</code></pre>

<p>第二种方法是使用 <code>=</code>，代码中的特殊字符将会被转义：</p>

<pre><code>p
  = 'This code is &lt;escaped&gt;!'
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;p&gt;This code is &amp;lt;escaped&amp;gt;!&lt;/p&gt;
</code></pre>

<p>第三种方法是使用 <code>!=</code>，代码中的特殊字符不会被转义：</p>

<pre><code>p
  = 'This code is &lt;escaped&gt;!'
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;p&gt;This code is &lt;escaped&gt;!&lt;/p&gt;
</code></pre>

<h2 id="插值语法"><a href="#插值语法" class="headerlink" title="插值语法"></a>插值语法</h2><p>这是我第二次听说插值的概念，但其实很好理解：使用插值语法，预先指定一个位置，方便以后插入一个新值，简称插值。这段话是我大半夜随性而发，意思到了即可，官方文档里可没有。</p>

<p>Jade 提供了字符串插值和标签插值。其中，字符串插值由于要考虑到安全性问题，所以又分成了转义和不转义两种情况：</p>

<pre><code>// 转义字符串插值 `#{}`
- var theGreat = "&lt;span&gt;escape!&lt;/span&gt;";
p This will be safe: #{theGreat}
// 不转义字符串插值 `!{}`
- var theGreat = "&lt;span&gt;escape!&lt;/span&gt;";
p This will be safe: !{theGreat}
// 标签插值
p #[a(href="jade-lang.com") Jade]
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;!-- 转义字符串插值 `#{}`--&gt;
&lt;p&gt;This will be safe: &amp;lt;span&amp;gt;escape!&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;!-- 不转义字符串插值 `!{}`--&gt;
&lt;p&gt;This will be safe: &lt;span&gt;escape!&lt;/span&gt;&lt;/p&gt;
&lt;!-- 标签插值--&gt;
&lt;p&gt;&lt;a href="jade-lang.com"&gt;Jade&lt;/a&gt;&lt;/p&gt;
</code></pre>

<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>说起条件语句，就必须谈到 <code>if … else if … else</code> 这个经典的条件判断，它也是 Jade 最基本的条件语句：</p>

<pre><code>- var user = { description: 'foo bar baz' }
- var authorised = false
#user
  if user.description
    h2 Description
    p.description= user.description
  else if authorised
    h2 Description
    p.description.
      User has no description,
      why not add one...
  else
    h1 Description
    p.description User has no description
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;div id="user"&gt;
  &lt;h2&gt;Description&lt;/h2&gt;
  &lt;p class="description"&gt;foo bar baz&lt;lt;/p&gt;
&lt;/div&gt;
</code></pre>

<p>此外，Jade 还提供了一个 <code>unless</code> 条件语句。如果说 <code>if</code> 可以通过判断<code>给定条件是否符合要求</code>来执行下一步，那么 <code>unless</code> 完全是相反的一件事，它会判断<code>给定条件是否不符合要求</code>，如果不符合，就执行下一步。</p>

<pre><code>- var con = false
unless con
  p Hello, World
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;p&gt;Hello, World&lt;/p&gt;
</code></pre>

<p>上面的逻辑结构看起来比生成的 HTML 繁琐多了，但这并不影响它是一种高效的解决方案，尤其是当你复用这段代码的时候。</p>

<h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2><p>当需要 <code>if</code> 判断的条件过多时，其他语言会提供类似 <code>switch</code> 的分支判断语句。在 Jade 中，也提供了类似的语法——<code>case</code>：</p>

<pre><code>- var friends = 10
case friends
  when 0
    p you have no friends
  when 1
    p you have a friend
  default
    p you have #{friends} friends
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;p&gt;you have 10 friends&lt;/p&gt;
</code></pre>

<p>在 Jade 中并没有提供类似 <code>break</code> 的语法，对于所有的条件默认只有一种输出结果，如果没有符合条件的就输出 <code>defualt</code> 中的内容。但是，有一个特例：</p>

<pre><code>- var friends = 0
case friends
  when 0
  when 1
  default
    p you have #{friends} friends
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;p&gt;you have very 0 friends&lt;/p&gt;
</code></pre>

<p>从上面的示例可以看出，当没有可输出内容时，就会执行向下查找可执行语句，一直查找到 <code>default</code>。</p>

<h2 id="遍历语句"><a href="#遍历语句" class="headerlink" title="遍历语句"></a>遍历语句</h2><p>Jade 使用 <code>each</code> 对数组和对象遍历，用法与 JavaScript 大同小异。</p>

<pre><code>// 遍历数组
ul
  each val, index in ['zero', 'one', 'two']
    li= index + ': ' + val

// 遍历对象
ul
  each val, index in {1:'one',2:'two',3:'three'}
    li= index + ': ' + val
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;!-- 遍历数组--&gt;
&lt;ul&gt;
  &lt;li&gt;0: zero&lt;/li&gt;
  &lt;li&gt;1: one&lt;/li&gt;
  &lt;li&gt;2: two&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- 遍历对象--&gt;
&lt;ul&gt;
  &lt;li&gt;1: one&lt;/li&gt;
  &lt;li&gt;2: two&lt;/li&gt;
  &lt;li&gt;3: three&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>Jade 使用 <code>while</code> 实现循环，用法还是中规中矩的与 JavaScript 相似：</p>

<pre><code>- var n = 0
ul
  while n &lt; 4
    li= n++
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;ul&gt;
  &lt;li&gt;0&lt;/li&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
  &lt;li&gt;3&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<h2 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h2><p>在 Scss 和 Jade 中，混合宏（mixins）都是举足轻重的语法。混合宏具有复用、解耦、可读、可扩。可维护等等优势。创建混合宏需要使用 <code>mixin</code> 标识符，创建混合宏实例时，需要使用 <code>+</code> 标识符：</p>

<pre><code>//- Declaration
mixin list
  ul
    li foo
    li bar
    li baz
//- Use
+list
+list
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;ul&gt;
  &lt;li&gt;foo&lt;/li&gt;
  &lt;li&gt;bar&lt;/li&gt;
  &lt;li&gt;baz&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
  &lt;li&gt;foo&lt;/li&gt;
  &lt;li&gt;bar&lt;/li&gt;
  &lt;li&gt;baz&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>上面是最基本的混合宏，此时它还不具有诸多优势，除非我们给它传递参数，才能让它具有非凡活力：</p>

<pre><code>mixin pet(name)
  li.pet= name
ul
  +pet('cat')
  +pet('dog')
  +pet('pig')
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;ul&gt;
  &lt;li class="pet"&gt;cat&lt;/li&gt;
  &lt;li class="pet"&gt;dog&lt;/li&gt;
  &lt;li class="pet"&gt;pig&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>此外，还可以使用 <code>…</code> 标识符表示不定数量的参数：</p>

<pre><code>mixin list(id, ...items)
  ul(id=id)
    each item in items
      li= item

+list('my-list', 1, 2, 3, 4)
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;ul id="my-list"&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
  &lt;li&gt;3&lt;/li&gt;
  &lt;li&gt;4&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>有时候，我们需要替换混合宏的某个部分，那么就可以使用 <code>block</code> 标识符来占位：</p>

<pre><code>mixin article(title)
  .article
    .article-wrapper
      h1= title
      if block
        block
      else
        p No content provided

+article('Hello world')

+article('Hello world')
  p This is my
  p Amazing article
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;div class="article"&gt;
  &lt;div class="article-wrapper"&gt;
    &lt;h1&gt;Hello world&lt;/h1&gt;
    &lt;p&gt;No content provided&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class="article"&gt;
  &lt;div class="article-wrapper"&gt;
    &lt;h1&gt;Hello world&lt;/h1&gt;
    &lt;p&gt;This is my&lt;/p&gt;
    &lt;p&gt;Amazing article&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>这种可替代语法，进一步提高了 Jade 的灵活性。</p>

<p>最后，我们谈谈有关属性的混合宏，官方文档中列举了两种用法，这里只介绍一种：</p>

<pre><code>mixin link(href, name)
  a(href=href)&amp;attributes(attributes)= name

+link('/foo', 'foo')(class="btn")
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;a href="/foo" class="btn"&gt;foo&lt;/a&gt;
</code></pre>

<p>上面混合宏中并没有声明 <code>attributes</code>，是因为 Jade 已经隐式为其引用了所有传递给 <code>&amp;attributes</code> 的参数。</p>

<h2 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h2><p>实现高度复用的另一种方式就是将代码片段保存到不同文件中，然后在需要的地方导入这些片段，为此，Jade 提供了 <code>include</code> 指令，下面是一个 <code>index</code> 页面：</p>

<pre><code>//- index.jade
doctype html
html
  include ./includes/head.jade
  body
    h1 My Site
    p Welcome to my super lame site.
    include ./includes/foot.jade
</code></pre>

<p><code>head</code> 代码片段：</p>

<pre><code>//- includes/head.jade
head
  title My Site
  script(src='/javascripts/jquery.js')
  script(src='/javascripts/app.js')
</code></pre>

<p><code>footer</code> 代码片段：</p>

<pre><code>//- includes/foot.jade
#footer
  p Copyright (c) foobar
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;My Site&lt;/title&gt;
    &lt;script src='/javascripts/jquery.js'&gt;&lt;/script&gt;
    &lt;script src='/javascripts/app.js'&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;My Site&lt;/h1&gt;
    &lt;p&gt;Welcome to my super lame site.&lt;/p&gt;
    &lt;div id="footer"&gt;
      &lt;p&gt;Copyright (c) foobar&lt;/p&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Jade 中使用 <code>extends</code> 来继承代码片段，与 <code>include</code> 本本分分地引用代码段不同，继承可以修改代码片段。</p>

<p>首先，在 <code>layout</code> 页面使用 <code>block</code> 标识符，设置一个可修改的代码片段，紧跟 <code>block</code> 标识符之后的是该代码片段的名字：</p>

<pre><code>//- layout.jade
doctype html
html
  head
    block title
      title Default title
  body
    block content
</code></pre>

<p>然后，在 <code>index</code> 页面继承 <code>layout</code>，并可以根据代码片段的名字修改相关代码：</p>

<pre><code>//- index.jade
extends ./layout.jade

block title
  title Article Title

block content
  h1 My Article
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Article Title&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;My Article&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>上述这种继承方式，会抹除原来代码片段的部分，如果想要追加代码片段，可以使用 <code>append</code> 和 <code>prepend</code> 指令。<code>append</code> 用于在原有代码片段之后追加，<code>prepend</code> 用于在原有代码片段之前追加。一个初始页面：</p>

<pre><code>//- layout.jade
html
  head
    title Layout
  body
    block content
      p Hello
</code></pre>

<p>使用 <code>append</code> ：</p>

<pre><code>extend layout

block append content
    p World
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;html&gt;
  &lt;head&gt;
    &llt;script src="/vendor/jquery.js"&gt;&lt;/script&gt;
    &lt;script src="/vendor/caustic.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Hello&lt;/p&gt;
    &lt;p&gt;World&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>使用 <code>prepend</code>：</p>

<pre><code>extend layout

block prepend content
    p World
</code></pre>

<p>生成的 HTML：</p>

<pre><code>&lt;html&gt;
  &lt;head&gt;
    &lt;script src="/vendor/jquery.js"&gt;&lt;/script&gt;
    &lt;script src="/vendor/caustic.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;World&lt;/p&gt;
    &lt;p&gt;Hello&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你还没有接触过模板引擎，那么就来试试 Jade 吧，它一定会有让你愉悦的一面。一直有一个梦想：三分钟敲完代码，简洁优美，剩下的人生尽情地去玩……</p>

<p></p><p>本文转自：<a href="http://www.w3cplus.com/html/jade.html" target="_blank" rel="external">http://www.w3cplus.com/html/jade.html</a></p><br>  <p></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[自动化构建工具gulp]]></title>
      <url>http://yoursite.com/2015/10/16/gulp/</url>
      <content type="html"><![CDATA[<h2 id="What-Is-Gulp"><a href="#What-Is-Gulp" class="headerlink" title="What Is Gulp?"></a>What Is Gulp?</h2><p>Gulp是一个构建系统，它能通过自动执行常见任务，比如编译预处理CSS，压缩JavaScript和刷新浏览器，来改进网站开发的过程。</p>
<p>Gulp是基于Node.js构建的，因此Gulp源文件和你用来定义任务的Gulp文件都被写进了JavaScript（或者CoffeeScript）里。</p>
<p>Gulp本身虽然不能完成很多任务，但它有大量插件可用，开发者可以访问插件页面或者在npm搜索gulpplugin就能看到。例如，有些插件可以用来执行JSHint、编译CoffeeScript，执行Mocha测试，甚至更新版本号。</p>
<p>Gulp中文网<a href="http://www.gulpjs.com.cn/" target="_blank" rel="external">http://www.gulpjs.com.cn/</a></p>
<p>Gulp是一个可以在GitHub上找到的开源项目。<br><a id="more"></a></p>
<h2 id="Installing-Gulp"><a href="#Installing-Gulp" class="headerlink" title="Installing Gulp"></a>Installing Gulp</h2><p>首先，需要在全局安装Gulp包，在终端输入：</p>
<pre><code>npm install -g gulp
</code></pre><p>g是global的缩写，表示全局安装，不加默认只在当前文件夹下安装</p>
<p>如果出现错误…….Error: EACCES: permission denied,………Please try running this command again as root/Administrator……可能是没有系统权限，要在命令前面加上sudo然后在运行，出现password时，输入计算机系统密码，输入密码时没有任何提示，也不会显示</p>
<p>然后，在项目里面安装Gulp：</p>
<pre><code>npm install gulp --save-dev 
</code></pre><p>该命令表示在npm上下载并安装gulp插件，通过–save（注意是两个–）-dev把该插件相关信息保存到一个package.json配置文件里,以备后用,执行完成后，会自动在项目根目录下创建一个node_modules文件夹</p>
<p>为了以后还能使用并更方便的使用此文件，我们执行一下npm的初始化：</p>
<pre><code>npm init
</code></pre><p>第一步输入name，如果不输入直接回车，默认name为根文件夹名，其余选项如果不指定皆可直接回车默认，ok后会在根目录文件夹下生成一个名为package.json的文件。<br>下次我们再使用的时候只要将此配置文件拷贝过去，然后执行npm install便会自动下载里面的所有插件。</p>
<h2 id="Using-Gulp"><a href="#Using-Gulp" class="headerlink" title="Using Gulp"></a>Using Gulp</h2><p>现在我们创建一个Gulp任务来压缩JavaScript文件。</p>
<p>首先需要在npm上搜索相关的js压缩插件，比如guip-jsmin插件，然后再终端安装插件</p>
<pre><code>npm install gulp-jsmin --save-dev
</code></pre><p>如果全局安装加个-g，如果因系统权限出错，加上sudo</p>
<p>然后，需要先准备好要被压缩的js文件，加入在项目根目录下的js文件夹下有一个a.js文件，</p>
<p>还要在根目录下创建一个名为gulpfile.js的文件，这是定义Gulp任务的地方。</p>
<pre><code>var gulp = require(&apos;gulp&apos;),           //前两句加载gulp和gulp-uglify模块
      jsmin = require(&apos;gulp-jsmin&apos;);

gulp.task(&apos;minjs&apos;, function () {    //定义一个名为minjs的任务，它执行时会调用函数，这个函数会作为第二个参数
    gulp.src(&apos;js/a.js&apos;)                //获取文要处理的文件的路径
     .pipe(jsmin())                    //该函数返回一个压缩后的对象
      .pipe(gulp.dest(&apos;newjs&apos;))        //该函数新建一个文件夹newjs，并把文件存到里面
});
</code></pre><p>函数里面定义了任务应该做什么，要理解里面的代码，我们需要引入一个知识点：</p>
<h2 id="STREAMS"><a href="#STREAMS" class="headerlink" title="STREAMS"></a>STREAMS</h2><p>数据流能够通过一系列的小函数来传递数据，这些函数会对数据进行修改，然后把修改后的数据传递给下一个函数。</p>
<p>在上面的例子中，gulp.src()函数用字符串匹配一个文件或者文件的编号（被称为“glob”）,然后创建一个对象流来代表这些文件，接着传递给uglify()函数，它接受文件对象之后返回有新压缩源文件的文件对象，最后那些输出的文件被输入gulp.dest()函数，并保存下来。</p>
<p>整个数据流动过程如下图所示：</p>
<p><img src="http://o7scv88yl.bkt.clouddn.com/gulp1.png"></p>
<p>当只有一个任务的时候，函数并不会起太大的作用。然而，仔细思考下面的代码：</p>
<pre><code>gulp.task(&apos;js&apos;, function () {
   return gulp.src(&apos;js/*.js&apos;)
      .pipe(jshint())
      .pipe(jshint.reporter(&apos;default&apos;))
      .pipe(uglify())
      .pipe(concat(&apos;app.js&apos;))
      .pipe(gulp.dest(&apos;build&apos;));
});
</code></pre><p>在运行这段程序之前，你需要先安装gulp,gulp-jshint,gulp-uglify和gulp-concat。</p>
<p>这个任务会让所有的文件匹配js/*.js（比如js目录下的所有JavaScript文件），并且执行JSHint，然后打印输出结果，取消文件缩进，最后把他们合并起来，保存为build/app.js，整个过程如下图所示： </p>
<p><img src="http://o7scv88yl.bkt.clouddn.com/gulp2.png"></p>
<p>如果你对Grunt 足够熟悉，就会注意到，Gulp和Grunt的工作方式很不一样。Grunt不使用数据流，而是使用文件，对文件执行单个任务然后保存到新的文件中，每个任务都会重复执行所有进程，文件系统频繁的处理任务会导致Grunt的运行速度比Gulp慢。</p>
<p>如果想要获取更加全面的数据流知识，请查看<a href="https://github.com/substack/stream-handbook" target="_blank" rel="external">“Stream Handbook”</a>.</p>
<h2 id="GULP-SRC"><a href="#GULP-SRC" class="headerlink" title="GULP.SRC()"></a>GULP.SRC()</h2><p>gulp.src()方法输入一个glob(比如匹配一个或多个文件的字符串)或者glob数组，然后返回一个可以传递给插件的数据流。</p>
<p>Gulp使用node-glob来从你指定的glob里面获取文件，这里列举下面的例子来阐述，方便大家理解：</p>
<ul>
<li>js/a.js 精确匹配文件</li>
<li>js/*.js 仅匹配js目录下的所有后缀为.js的文件</li>
<li>js/*/.js 匹配js目录及其子目录下所有后缀为.js的文件</li>
<li>!js/a.js 从匹配结果中排除js/app.js，这种方法在你想要匹配除了特殊文件之外的所有文件时非常管用</li>
<li>*.+(js|css) 匹配根目录下所有后缀为.js或者.css的文件</li>
</ul>
<p>此外，Gulp也有很多其他的特征，但并不常用。如果你想了解更多的特征，请查看<a href="https://github.com/isaacs/minimatch" target="_blank" rel="external">Minimatch</a>文档。</p>
<p>js目录下包含了压缩和未压缩的JavaScript文件，现在我们想要创建一个任务来压缩还没有被压缩的文件，我们需要先匹配目录下所有的JavaScript文件，然后排除后缀为.min.js的文件:</p>
<pre><code>gulp.src([&apos;js/**/*.js&apos;, &apos;!js/**/*.min.js&apos;])
</code></pre><h2 id="DEFINING-TASKS"><a href="#DEFINING-TASKS" class="headerlink" title="DEFINING TASKS"></a>DEFINING TASKS</h2><p>gulp.task()函数通常会被用来定义任务。当你定义一个简单的任务时，需要传入任务名字和执行函数两个属性。</p>
<pre><code>gulp.task(&apos;greet&apos;, function () {
   console.log(&apos;Hello world!&apos;);
});
</code></pre><p>执行gulp greet的结果就是在控制台上打印出“Hello world”.</p>
<p>一个任务有时也可以是一系列任务。假设要定义一个任务build来执行css、js、imgs这三个任务，我们可以通过指定一个任务数组而不是函数来完成。</p>
<pre><code>gulp.task(&apos;build&apos;, [&apos;css&apos;, &apos;js&apos;, &apos;imgs&apos;]);
</code></pre><p>这些任务不是同时进行的，所以你不能认为在js任务开始的时候css任务已经结束了，也可能还没有结束。为了确保一个任务在另一个任务执行前已经结束，可以将函数和任务数组结合起来指定其依赖关系。例如，定义一个css任务，在执行前需要检查greet任务是否已经执行完毕，这样做就是可行的:</p>
<pre><code>gulp.task(&apos;css&apos;, [&apos;greet&apos;], function () {
   // Deal with CSS here
});
</code></pre><p>现在，当执行css任务时，Gulp会先执行greet任务，然后在它结束后再调用你定义的函数。</p>
<h2 id="DEFAULT-TASKS"><a href="#DEFAULT-TASKS" class="headerlink" title="DEFAULT TASKS"></a>DEFAULT TASKS</h2><p>你可以定义一个在gulp开始运行时候默认执行的任务，并将这个任务命名为“default”：</p>
<pre><code>gulp.task(&apos;default&apos;, function () {
   // Your default task
});
</code></pre><h2 id="PLUGINS"><a href="#PLUGINS" class="headerlink" title="PLUGINS"></a>PLUGINS</h2><p>Gulp上有超过600种插件供你选择，你可以在插件页面或者npm上搜索gulpplugin来浏览插件列表。有些拥有“gulpfriendly”标签的插件，他们不能算插件，但是能在Gulp上正常运行。 需要注意的是，当直接在npm里搜索时，你无法知道某一插件是否在黑名单上（你需要滚动到插件页面底部才能看到）。</p>
<p>大多数插件的使用都很方便，它们都配有详细的文档，而且调用方法也相同（通过传递文件对象流给它），它们通常会对这些文件进行修改（但是有一些插件例外，比如validators），最后返回新的文件给下一个插件。</p>
<p>让我们用前面的js任务来详细说明一下：</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
jshint = require(&apos;gulp-jshint&apos;),
uglify = require(&apos;gulp-uglify&apos;),
concat = require(&apos;gulp-concat&apos;);

gulp.task(&apos;js&apos;, function () {
   return gulp.src(&apos;js/*.js&apos;)
  .pipe(jshint())
  .pipe(jshint.reporter(&apos;default&apos;))
  .pipe(uglify())
  .pipe(concat(&apos;app.js&apos;))
  .pipe(gulp.dest(&apos;build&apos;));
});
</code></pre><p>这里使用了三个插件，gulp-jshint,gulp-uglify和gulp-concat。开发者可以参考插件的README文档，插件有很多配置选项，而且给定的初始值通常能满足需求。细心的读者可能会发现，程序中JSHint插件执行了2次，这是因为第一次执行JSHint只是给文件对象附加了jshint属性，并没有输出。你可以自己读取jshint的属性或者传递给默认的JSHint的接收函数或者其他的接收函数,比如jshint-stylish.</p>
<p>其他两个插件的作用很清楚：uglify()函数压缩代码，concat(‘app.js’)函数将所有文件合并到一个叫app.js的文件中。</p>
<h2 id="GULP-LOAD-PLUGINS"><a href="#GULP-LOAD-PLUGINS" class="headerlink" title="GULP-LOAD-PLUGINS"></a>GULP-LOAD-PLUGINS</h2><p>我发现gulp-load-plugin模块十分有用，它能够自动地从package.json中加载任意Gulp插件然后把它们附加到一个对象上。它的基本用法如下所示：</p>
<pre><code>var gulpLoadPlugins = require(&apos;gulp-load-plugins&apos;),
plugins = gulpLoadPlugins();
</code></pre><p>你可以把所有代码写到一行，但是我并不推荐这样做。</p>
<p>在执行那些代码之后，插件对象就已经包含了插件，并使用“驼峰式”的方式进行命名（例如，gulp-ruby-sass将被加载成plugins.rubySass），这样就可以很方便地使用了。例如，前面的js任务简化为如下：</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
gulpLoadPlugins = require(&apos;gulp-load-plugins&apos;),
plugins = gulpLoadPlugins();

gulp.task(&apos;js&apos;, function () {
   return gulp.src(&apos;js/*.js&apos;)
  .pipe(plugins.jshint())
  .pipe(plugins.jshint.reporter(&apos;default&apos;))
  .pipe(plugins.uglify())
  .pipe(plugins.concat(&apos;app.js&apos;))
  .pipe(gulp.dest(&apos;build&apos;));
});
</code></pre><p>假设package.json文件如下面所示：</p>
<pre><code>{
       &quot;devDependencies&quot;: {
           &quot;gulp-concat&quot;: &quot;~2.2.0&quot;,
          &quot;gulp-uglify&quot;: &quot;~0.2.1&quot;,
          &quot;gulp-jshint&quot;: &quot;~1.5.1&quot;,
          &quot;gulp&quot;: &quot;~3.5.6&quot;
       }
}
</code></pre><p>这个例子虽然已经够短了，但是使用更长更复杂的Gulp文件会把它们简化成一两行代码。</p>
<p>Gulp-load-plugins0.4.0版本添加了延迟加载功能，提高了插件的性能，因为插件在使用的时候才会被加载进来，你不用担心package.json里未被使用的插件影响性能（但是你需要把他们清理掉）。换句话说，如果你在执行任务时只需要两个插件，那么其他不相关的插件就不会被加载。</p>
<h2 id="WATCHING-FILES"><a href="#WATCHING-FILES" class="headerlink" title="WATCHING FILES"></a>WATCHING FILES</h2><p>Gulp可以监听文件的修改动态，然后在文件被改动的时候执行一个或多个任务。这个特性十分有用（对我来说，这可能是Gulp中最有用的一个功能）。你可以保存LESS文件，接着Gulp会自动把它转换为CSS文件并更新浏览器。</p>
<p>使用gulp.watch()方法可以监听文件，它接受一个glob或者glob数组（和gulp.src()一样）以及一个任务数组来执行回调。</p>
<p>让我们看看下面，build任务可以将模板转换成html格式，然后我们希望定义一个watch任务来监听模板文件的变化，并将这些模板转换成html格式。watch函数的使用方法如下所示：</p>
<pre><code>gulp.task(&apos;watch&apos;, function () {
      gulp.watch(&apos;templates/*.tmpl.html&apos;, [&apos;build&apos;]);
});
</code></pre><p>现在，当改变一个模板文件时，build任务会被执行并生成HTML文件，也可以给watch函数一个回调函数，而不是一个任务数组。在这个示例中，回调函数有一个包含触发回调函数信息的event对象：</p>
<pre><code>gulp.watch(&apos;templates/*.tmpl.html&apos;, function (event) {
       console.log(&apos;Event type: &apos; + event.type); // added, changed, or deleted
       console.log(&apos;Event path: &apos; + event.path); // The path of the modified file
});
</code></pre><p>Gulp.watch()的另一个非常好的特性是返回我们熟知的watcher。利用watcher来监听额外的事件或者向watch中添加文件。例如，在执行一系列任务和调用一个函数时，你就可以在返回的watcher中添加监听change事件:</p>
<pre><code>var watcher = gulp.watch(&apos;templates/*.tmpl.html&apos;, [&apos;build&apos;]);
watcher.on(&apos;change&apos;, function (event) {
      console.log(&apos;Event type: &apos; + event.type); // added, changed, or deleted
       console.log(&apos;Event path: &apos; + event.path); // The path of the modified file
});
</code></pre><p>除了change事件，还可以监听很多其他的事件:</p>
<ul>
<li>end 在watcher结束时触发（这意味着，在文件改变的时候，任务或者回调不会执行）</li>
<li>error 在出现error时触发</li>
<li>ready 在文件被找到并正被监听时触发</li>
<li>nomatch 在glob没有匹配到任何文件时触发</li>
</ul>
<p>Watcher对象也包含了一些可以调用的方法：</p>
<ul>
<li>watcher.end() 停止watcher（以便停止执行后面的任务或者回调函数）<ul>
<li>watcher.files() 返回watcher监听的文件列表</li>
<li>watcher.add(glob) 将与指定glob相匹配的文件添加到watcher（也接受可选的回调当第二个参数）</li>
</ul>
</li>
<li>watcher.remove(filepath) 从watcher中移除个别文件</li>
</ul>
<h2 id="Reloading-Changes-In-The-Browser"><a href="#Reloading-Changes-In-The-Browser" class="headerlink" title="Reloading Changes In The Browser"></a>Reloading Changes In The Browser</h2><p>当一个文件被修改或者Gulp任务被执行时可以用Gulp来加载或者更新网页。LiveReload和BrowserSync插件就可以用来实现在游览器中加载更新的内容。</p>
<h2 id="LIVERELOAD"><a href="#LIVERELOAD" class="headerlink" title="LIVERELOAD"></a>LIVERELOAD</h2><p>LiveReload结合了浏览器扩展（包括Chrome extension），在发现文件被修改时会实时更新网页。它可以和gulp-watch插件或者前面描述的gulp-watch()函数一起使用。下面有一个gulp-livereload仓库中的README文件提到的例子:</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
        less = require(&apos;gulp-less&apos;),
    livereload = require(&apos;gulp-livereload&apos;),
    watch = require(&apos;gulp-watch&apos;);

gulp.task(&apos;less&apos;, function() {
       gulp.src(&apos;less/*.less&apos;)
      .pipe(watch())
      .pipe(less())
      .pipe(gulp.dest(&apos;css&apos;))
      .pipe(livereload());
});
</code></pre><p>这会监听到所有与less/*.less相匹配的文件的变化。一旦监测到变化，就会生成css并保存，然后重新加载网页.</p>
<h2 id="BROWSERSYNC"><a href="#BROWSERSYNC" class="headerlink" title="BROWSERSYNC"></a>BROWSERSYNC</h2><p>BroserSync在浏览器中展示变化的功能与LiveReload非常相似，但是它有更多的功能。</p>
<p>当你改变代码的时候，BrowserSync会重新加载页面，或者如果是css文件，会直接添加进css中，页面并不需要再次刷新。这项功能在网站是禁止刷新的时候是很有用的。假设你正在开发单页应用的第4页，刷新页面就会导致你回到开始页。使用LiveReload的话，你就需要在每次改变代码之后还需要点击四次，而当你修改CSS时，插入一些变化时，BrowserSync会直接将需要修改的地方添加进CSS，就不用再点击回退。</p>
<p><img src="http://o7scv88yl.bkt.clouddn.com/gulp3.gif"></p>
<p>BrowserSync提供了一种在多个浏览器里测试网页的很好方式。</p>
<p>BrowserSync也可以在不同浏览器之间同步点击翻页、表单操作、滚动位置。你可以在电脑和iPhone上打开不同的浏览器然后进行操作。所有设备上的链接将会随之变化，当你向下滚动页面时，所有设备上页面都会向下滚动（通常还很流畅！）。当你在表单中输入文本时，每个窗口都会有输入。当你不想要这种行为时，也可以把这个功能关闭。</p>
<p><img src="http://o7scv88yl.bkt.clouddn.com/gulp4.gif"></p>
<p>BrowserSync不需要使用浏览器插件，因为它本身就可以给你提供文件。</p>
<p>BrowserSync不需要使用浏览器插件，因为它本身就可以为你提供文件服务（如果文件是动态的，则为他们提供代理服务）和用来开启浏览器和服务器之间的socket的脚本服务。到目前为止这个功能的使用都十分顺畅。</p>
<p>实际上BrowserSync对于Gulp并不算一种插件，因为BrowserSync并不像一个插件一样操作文件。然而，npm上的BrowserSync模块能在Gulp上被直接调用。</p>
<p>首先，需要通过npm安装一下：</p>
<pre><code>npm install --save-dev browser-sync
</code></pre><p>然后gulpfile.js会启动BrowserSync并监听文件：</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
browserSync = require(&apos;browser-sync&apos;);

gulp.task(&apos;browser-sync&apos;, function () {
   var files = [
  &apos;app/**/*.html&apos;,
  &apos;app/assets/css/**/*.css&apos;,
  &apos;app/assets/imgs/**/*.png&apos;,
  &apos;app/assets/js/**/*.js&apos;
   ];

   browserSync.init(files, {
      server: {
         baseDir: &apos;./app&apos;
      }
   });
});
</code></pre><p>执行gulp browser-sync后会监听匹配文件的变化，同时为app目录提供文件服务。</p>
<p>此外BrowserSync的开发者还写了很多关于BrowserSync+Gulp仓库的其他用途。</p>
<h2 id="Why-Gulp"><a href="#Why-Gulp" class="headerlink" title="Why Gulp?"></a>Why Gulp?</h2><p>前面提到过，Gulp是为数不多的使用JavaScript开发的构建工具之一，也有其他不是用JavaScript开发的构建工具，比如Rake，那么我们为什么要选择Gulp呢?</p>
<p>目前最流行的两种使用JavaScript开发的构建工具是Grunt和Gulp。Grunt在2013年非常流行，因为它彻底改变了许多人开发网站的方式，它有上千种插件可供用户使用，从linting、压缩、合并代码到使用Bower安装程序包,启动Express服务都能办到。这些和Gulp的很不一样，Gulp只有执行单个小任务来处理文件的插件，因为任务都是JavaScript（和Grunt使用的大型对象不同），根本不需要插件，你只需用传统方法启动一个Express服务就可以了。</p>
<p>Grunt任务拥有大量的配置，会引用大量你实际上并不需要的对象属性，但是Gulp里同样的任务也许只有几行。让我们看个简单的Gruntfile.js，它规定一个将LESS转换为CSS的任务，然后执行Autoprefixer:</p>
<pre><code>grunt.initConfig({
       less: {
       development: {
         files: {
            &quot;build/tmp/app.css&quot;: &quot;assets/app.less&quot;
         }
            }
       },

       autoprefixer: {
          options: {
              browsers: [&apos;last 2 version&apos;, &apos;ie 8&apos;, &apos;ie 9&apos;]
           },
            multiple_files: {
                 expand: true,
             flatten: true,
             src: &apos;build/tmp/app.css&apos;,
             dest: &apos;build/&apos;
              }
       }
});

grunt.loadNpmTasks(&apos;grunt-contrib-less&apos;);
grunt.loadNpmTasks(&apos;grunt-autoprefixer&apos;);

grunt.registerTask(&apos;css&apos;, [&apos;less&apos;, &apos;autoprefixer&apos;]);
</code></pre><p>与Gulpfile.js文件进行对比，它们执行的任务相同：</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
       less = require(&apos;gulp-less&apos;),
       autoprefix = require(&apos;gulp-autoprefixer&apos;);

gulp.task(&apos;css&apos;, function () {
       gulp.src(&apos;assets/app.less&apos;)
      .pipe(less())
      .pipe(autoprefix(&apos;last 2 version&apos;, &apos;ie 8&apos;, &apos;ie 9&apos;))
      .pipe(gulp.dest(&apos;build&apos;));
});
</code></pre><p>因为Grunt比Gulp更加频繁地操作文件系统，所以使用数据流的Gulp总是比Grunt快。对于一个小的LESS文件，gulpfile.js通常需要6ms，而gruntfile.js则需要大概50ms——慢8倍多。这只是个简单的例子，对于长的文件，这个数字会增加得更显著。</p>
<h2 id="安装gulp插件"><a href="#安装gulp插件" class="headerlink" title="安装gulp插件"></a>安装gulp插件</h2><p>一些外挂：</p>
<ul>
<li>编译Sass (gulp-ruby-sass)</li>
<li>Autoprefixer (gulp-autoprefixer)</li>
<li>缩小化(minify)CSS (gulp-minify-css)<ul>
<li>JSHint (gulp-jshint)</li>
</ul>
</li>
<li>拼接 (gulp-concat)</li>
<li>丑化(Uglify) (gulp-uglify)</li>
<li>图片压缩 (gulp-imagemin)</li>
<li>即时重整(LiveReload) (gulp-livereload)</li>
<li>清理档案 (gulp-clean)<ul>
<li>图片快取，只有更改过得图片会进行压缩 (gulp-cache)</li>
</ul>
</li>
<li>更动通知 (gulp-notify)</li>
</ul>
<p>安装这些外挂:</p>
<pre><code>$ npm install gulp-ruby-sass gulp-autoprefixer gulp-minify-css gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-clean gulp-notify gulp-rename gulp-livereload gulp-cache --save-dev
</code></pre><p>指令将会安装必要的外挂，并纪录于package.json内的devDependencies物件。</p>
<h2 id="在gulpfile-js载入这些外挂："><a href="#在gulpfile-js载入这些外挂：" class="headerlink" title="在gulpfile.js载入这些外挂："></a>在gulpfile.js载入这些外挂：</h2><pre><code>var gulp = require(&apos;gulp&apos;),  
        sass = require(&apos;gulp-ruby-sass&apos;),
    autoprefixer = require(&apos;gulp-autoprefixer&apos;),
    minifycss = require(&apos;gulp-minify-css&apos;),
    jshint = require(&apos;gulp-jshint&apos;),
    uglify = require(&apos;gulp-uglify&apos;),
    imagemin = require(&apos;gulp-imagemin&apos;),
    rename = require(&apos;gulp-rename&apos;),
       clean = require(&apos;gulp-clean&apos;),
    concat = require(&apos;gulp-concat&apos;),
    notify = require(&apos;gulp-notify&apos;),
    cache = require(&apos;gulp-cache&apos;),
    livereload = require(&apos;gulp-livereload&apos;);
</code></pre><p>呼！看起来比Grunt有更多的事要做，对吧？Gulp外挂跟Grunt外挂有些许差异–它被设计成做一件事并且做好一件事。例如；Grunt的imagemin利用快取来避免重複压缩已经压缩好的图片。在Gulp中，这必须透过一个快取外挂来达成，当然，快取外挂也可以拿来快取其他东西。这让建构过程中增加了额外的弹性层面。蛮酷的，哼？</p>
<p>我们也可以像Grunt一样自动载入所有已安装的外挂，但这不在此文章目的，所以我们将维持在手动的方式。</p>
<h2 id="载入外挂"><a href="#载入外挂" class="headerlink" title="载入外挂"></a>载入外挂</h2><p>接下来，我们需要建立一个gulpfile.js档案，并且载入这些外挂：</p>
<pre><code>var gulp = require(&apos;gulp&apos;),  
sass = require(&apos;gulp-ruby-sass&apos;),
autoprefixer = require(&apos;gulp-autoprefixer&apos;),
minifycss = require(&apos;gulp-minify-css&apos;),
jshint = require(&apos;gulp-jshint&apos;),
uglify = require(&apos;gulp-uglify&apos;),
imagemin = require(&apos;gulp-imagemin&apos;),
rename = require(&apos;gulp-rename&apos;),
clean = require(&apos;gulp-clean&apos;),
concat = require(&apos;gulp-concat&apos;),
notify = require(&apos;gulp-notify&apos;),
cache = require(&apos;gulp-cache&apos;),
livereload = require(&apos;gulp-livereload&apos;);
</code></pre><p>呼！看起来比Grunt有更多的事要做，对吧？Gulp外挂跟Grunt外挂有些许差异–它被设计成做一件事并且做好一件事。例如；Grunt的imagemin利用快取来避免重複压缩已经压缩好的图片。在Gulp中，这必须透过一个快取外挂来达成，当然，快取外挂也可以拿来快取其他东西。这让建构过程中增加了额外的弹性层面。蛮酷的，哼？</p>
<p>我们也可以像Grunt一样自动载入所有已安装的外挂，但这不在此文章目的，所以我们将维持在手动的方式。</p>
<h2 id="建立任务"><a href="#建立任务" class="headerlink" title="建立任务"></a>建立任务</h2><p>编译Sass，Autoprefix及缩小化</p>
<p>首先，我们设置编译Sass。我们将编译Sass、接著通过Autoprefixer，最后储存结果到我们的目的地。接著产生一个缩小化的.min版本、自动重新整理页面及通知任务已经完成：</p>
<pre><code>gulp.task(&apos;styles&apos;, function() {  
  return gulp.src(&apos;src/styles/main.scss&apos;)
 .pipe(sass({ style: &apos;expanded&apos; }))
 .pipe(autoprefixer(&apos;last 2 version&apos;, &apos;safari 5&apos;, &apos;ie 8&apos;, &apos;ie 9&apos;, &apos;opera 12.1&apos;, &apos;ios 6&apos;, &apos;android 4&apos;))
 .pipe(gulp.dest(&apos;dist/assets/css&apos;))
 .pipe(rename({suffix: &apos;.min&apos;}))
 .pipe(minifycss())
 .pipe(gulp.dest(&apos;dist/assets/css&apos;))
 .pipe(notify({ message: &apos;Styles task complete&apos; }));
});
</code></pre><p>继续下去之前，一个小小的说明。</p>
<pre><code>gulp.task(&apos;styles&apos;, function() { ... )};  
</code></pre><p>这个gulp.taskAPI用来建立任务。可以透过终端机输入$ gulp styles指令来执行上述任务。</p>
<pre><code>return gulp.src(&apos;src/styles/main.scss&apos;)  
</code></pre><p>这个gulp.srcAPI用来定义一个或多个来源档案。允许使用glob样式，例如/<em>*/</em>.scss比对多个符合的档案。传回的串流(stream)让它成为非同步机制，所以在我们收到完成通知之前，确保该任务已经全部完成。</p>
<pre><code>.pipe(sass({ style: &apos;expanded&apos; }))
</code></pre><p>使用pipe()来串流来源档案到某个外挂。外挂的选项通常在它们各自的Github页面中可以找到。上面列表中我有留下各个外挂的连结，让你方便使用。</p>
<pre><code>.pipe(gulp.dest(&apos;dist/assets/css&apos;));
</code></pre><p>这个gulp.dest()API是用来设定目的路径。一个任务可以有多个目的地，一个用来输出扩展的版本，一个用来输出缩小化的版本。这个在上述的styles任务中已经有展示。</p>
<p>我建议阅读gulp的API文件，以了解这些函式方法。它们并不像看起来的那样可怕！</p>
<h2 id="JSHint，拼接及缩小化JavaScript"><a href="#JSHint，拼接及缩小化JavaScript" class="headerlink" title="JSHint，拼接及缩小化JavaScript"></a>JSHint，拼接及缩小化JavaScript</h2><p>希望你现在对于如何建立一个新的gulp任务有好想法。接下来，我们将设定脚本任务，包括lint、拼接及丑化:</p>
<pre><code>gulp.task(&apos;scripts&apos;, function() {  
     return gulp.src(&apos;src/scripts/**/*.js&apos;)
    .pipe(jshint(&apos;.jshintrc&apos;))
    .pipe(jshint.reporter(&apos;default&apos;))
    .pipe(concat(&apos;main.js&apos;))
    .pipe(gulp.dest(&apos;dist/assets/js&apos;))
    .pipe(rename({suffix: &apos;.min&apos;}))
    .pipe(uglify())
    .pipe(gulp.dest(&apos;dist/assets/js&apos;))
    .pipe(notify({ message: &apos;Scripts task complete&apos; }));
});
</code></pre><p>一件事提醒，我们需要指定JSHint一个reporter。这裡我使用预设的reporter，适用于大多数人。更多有关此设定，你可以在JSHint网站取得。</p>
<h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><p>接著，我们将设定图片压缩:</p>
<pre><code>gulp.task(&apos;images&apos;, function() {  
      return gulp.src(&apos;src/images/**/*&apos;)
    .pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))
    .pipe(gulp.dest(&apos;dist/assets/img&apos;))
    .pipe(notify({ message: &apos;Images task complete&apos; }));
});
</code></pre><p>这会将对所有来源图片进行imagemin处理。我们可以稍微更进一步，利用快取保存已经压缩过的图片，以便每次进行此任务时不需要再重新压缩。这裡只需要gulp-cache外挂–稍早已经安装。我们需要额外设置才能使用这个外挂，因此修改这段程式码:</p>
<pre><code>.pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))
</code></pre><p>成为这段:</p>
<pre><code>.pipe(cache(imagemin({ optimizationLevel: 5, progressive: true, interlaced: true })))
</code></pre><p>现在只有新的或更动的图片会被压缩。乾淨俐落!</p>
<h2 id="收拾乾淨"><a href="#收拾乾淨" class="headerlink" title="收拾乾淨!"></a>收拾乾淨!</h2><p>在我们进行佈署之前，清除目的地目录并重建档案是一个好主意–以防万一任何已经被删除的来源档案遗留在目的地目录之中:</p>
<pre><code>gulp.task(&apos;clean&apos;, function() {  
      return gulp.src([&apos;dist/assets/css&apos;, &apos;dist/assets/js&apos;, &apos;dist/assets/img&apos;], {read: false})
    .pipe(clean());
});
</code></pre><p>我们可以传入一个目录(或档案)阵列到gulp.src。因为我们不想要读取已经被删除的档案，我们可以加入read: false选项来防止gulp读取档案内容–让它快一些。</p>
<h2 id="预设任务"><a href="#预设任务" class="headerlink" title="预设任务"></a>预设任务</h2><p>我们可以建立一个预设任务，当只输入$ gulp指令时执行的任务，这裡执行三个我们所建立的任务:</p>
<pre><code>gulp.task(&apos;default&apos;, [&apos;clean&apos;], function() {  
    gulp.start(&apos;styles&apos;, &apos;scripts&apos;, &apos;images&apos;);
});
</code></pre><p>注意额外传入gulp.task的阵列。这裡我们可以定义任务相依(task dependencies)。在这个范例中，gulp.start开始任务前会先执行清理(clean)任务。Gulp中所有的任务都是并行(concurrently)执行，并没有先后顺序哪个任务会先完成，所以我们需要确保clean任务在其他任务开始前完成。</p>
<p><b>注意:</b> 透过相依任务阵列来执行clean而非gulp.start是经过考虑的，在这个情境来看是最好的选择，以确保清理任务全部完成。</p>
<h2 id="看守"><a href="#看守" class="headerlink" title="看守"></a>看守</h2><p>为了能够看守档案，并在更动发生后执行相关任务，首先需要建立一个新的任务，使用gulp.watchAPI来看守档案:</p>
<pre><code>gulp.task(&apos;watch&apos;, function() {

      // 看守所有.scss档
      gulp.watch(&apos;src/styles/**/*.scss&apos;, [&apos;styles&apos;]);

      // 看守所有.js档
      gulp.watch(&apos;src/scripts/**/*.js&apos;, [&apos;scripts&apos;]);

      // 看守所有图片档
      gulp.watch(&apos;src/images/**/*&apos;, [&apos;images&apos;]);

});
</code></pre><p>透过gulp.watch指定想要看守的档案，并且透过相依任务阵列定义任务。执行$ gulp watch来开始看守档案，任何.scss、.js或图片档案一旦有了更动，便会执行相对应的任务。</p>
<h2 id="即时重整-LiveReload"><a href="#即时重整-LiveReload" class="headerlink" title="即时重整(LiveReload)"></a>即时重整(LiveReload)</h2><p>Gulp也可以处理档案更动后，自动重新整理页面。我们需要修改watch任务，设置即时重整伺服器。</p>
<pre><code>gulp.task(&apos;watch&apos;, function() {

      // 建立即时重整伺服器
      var server = livereload();

      // 看守所有位在 dist/  目录下的档案，一旦有更动，便进行重整
      gulp.watch([&apos;dist/**&apos;]).on(&apos;change&apos;, function(file) {
         server.changed(file.path);
       });

});
</code></pre><p>为了让这个功能有效，除了伺服器之外，还需要安装并启用LiveReload的浏览器外挂。或者你也可以手动加上这个片段程式码。</p>
<h2 id="全部在一起"><a href="#全部在一起" class="headerlink" title="全部在一起"></a>全部在一起</h2><p>这裡是完整的gulpfile:</p>
<pre><code>// 载入外挂
var gulp = require(&apos;gulp&apos;),  
sass = require(&apos;gulp-ruby-sass&apos;),
autoprefixer = require(&apos;gulp-autoprefixer&apos;),
minifycss = require(&apos;gulp-minify-css&apos;),
jshint = require(&apos;gulp-jshint&apos;),
uglify = require(&apos;gulp-uglify&apos;),
imagemin = require(&apos;gulp-imagemin&apos;),
rename = require(&apos;gulp-rename&apos;),
clean = require(&apos;gulp-clean&apos;),
concat = require(&apos;gulp-concat&apos;),
notify = require(&apos;gulp-notify&apos;),
cache = require(&apos;gulp-cache&apos;),
livereload = require(&apos;gulp-livereload&apos;);

// 样式
gulp.task(&apos;styles&apos;, function() {  
 return gulp.src(&apos;src/styles/main.scss&apos;)
       .pipe(sass({ style: &apos;expanded&apos;, }))
     .pipe(autoprefixer(&apos;last 2 version&apos;, &apos;safari 5&apos;, &apos;ie 8&apos;, &apos;ie 9&apos;, &apos;opera 12.1&apos;, &apos;ios 6&apos;, &apos;android 4&apos;))
    .pipe(gulp.dest(&apos;dist/styles&apos;))
    .pipe(rename({ suffix: &apos;.min&apos; }))
    .pipe(minifycss())
       .pipe(gulp.dest(&apos;dist/styles&apos;))
    .pipe(notify({ message: &apos;Styles task complete&apos; }));
});

// 脚本
gulp.task(&apos;scripts&apos;, function() {  
      return gulp.src(&apos;src/scripts/**/*.js&apos;)
    .pipe(jshint(&apos;.jshintrc&apos;))
    .pipe(jshint.reporter(&apos;default&apos;))
    .pipe(concat(&apos;main.js&apos;))
    .pipe(gulp.dest(&apos;dist/scripts&apos;))
    .pipe(rename({ suffix: &apos;.min&apos; }))
    .pipe(uglify())
    .pipe(gulp.dest(&apos;dist/scripts&apos;))
    .pipe(notify({ message: &apos;Scripts task complete&apos; }));
});

// 图片
gulp.task(&apos;images&apos;, function() {  
      return gulp.src(&apos;src/images/**/*&apos;)
    .pipe(cache(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true })))
    .pipe(gulp.dest(&apos;dist/images&apos;))
    .pipe(notify({ message: &apos;Images task complete&apos; }));
});

// 清理
gulp.task(&apos;clean&apos;, function() {  
      return gulp.src([&apos;dist/styles&apos;, &apos;dist/scripts&apos;, &apos;dist/images&apos;], {read: false})
    .pipe(clean());
});

// 预设任务
gulp.task(&apos;default&apos;, [&apos;clean&apos;], function() {  
    gulp.start(&apos;styles&apos;, &apos;scripts&apos;, &apos;images&apos;);
});

// 看守
gulp.task(&apos;watch&apos;, function() {

      // 看守所有.scss档
      gulp.watch(&apos;src/styles/**/*.scss&apos;, [&apos;styles&apos;]);

      // 看守所有.js档
      gulp.watch(&apos;src/scripts/**/*.js&apos;, [&apos;scripts&apos;]);

      // 看守所有图片档
      gulp.watch(&apos;src/images/**/*&apos;, [&apos;images&apos;]);

      // 建立即时重整伺服器
      var server = livereload();

      // 看守所有位在 dist/  目录下的档案，一旦有更动，便进行重整
      gulp.watch([&apos;dist/**&apos;]).on(&apos;change&apos;, function(file) {
            server.changed(file.path);
      });

});
</code></pre><p>本文参考：</p>
<p><a href="http://www.w3ctech.com/topic/134" target="_blank" rel="external">http://www.w3ctech.com/topic/134</a></p>
<p><a href="http://www.techug.com/gulp" target="_blank" rel="external">http://www.techug.com/gulp</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo博客搭建]]></title>
      <url>http://yoursite.com/2015/09/18/hexoBlog/</url>
      <content type="html"><![CDATA[<h2 id="本文将教大家怎么搭建hexo博客"><a href="#本文将教大家怎么搭建hexo博客" class="headerlink" title="本文将教大家怎么搭建hexo博客"></a>本文将教大家怎么搭建hexo博客</h2><h3 id="准备工作（本文所有操作均在mac系统下执行）："><a href="#准备工作（本文所有操作均在mac系统下执行）：" class="headerlink" title="准备工作（本文所有操作均在mac系统下执行）："></a>准备工作（本文所有操作均在mac系统下执行）：</h3><h4 id="1-搭建Node-js运行环境"><a href="#1-搭建Node-js运行环境" class="headerlink" title="1.搭建Node.js运行环境"></a>1.搭建Node.js运行环境</h4><p>hexo是一个基于Node.js的第三方模块，能够生成一个<code>静态</code>博客框架，所以要搭建hexo需要先安装node.js</p>
<p>Node.js<a href="https://nodejs.org/en/" target="_blank" rel="external">下载地址</a> 建议安装LTS稳定版<br><a id="more"></a><br>该文件属于系统文件，安装后没有自己的图标进口，可通过在终端输入以下命令查看是否安装成功：</p>
<pre><code>$ node -v
</code></pre><p>该命令是打印Node.js的版本,如果显示版本号（version），表示安装成功。</p>
<h4 id="2-git账号以及本地环境搭建"><a href="#2-git账号以及本地环境搭建" class="headerlink" title="2.git账号以及本地环境搭建"></a>2.git账号以及本地环境搭建</h4><p>这个教程大家可以参考我上一篇博客 <a href="http://gaoke700.github.io/2015/09/17/%E6%9C%AC%E5%9C%B0git%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="blank">[点此打开]</a></p>
<p>新建一个仓库，仓库名（即博客地址）设置为yourgitname.github.io</p>
<p>比如我的git账号是gaoke700，那我的这个博客域名就是 gaoke700.github.io</p>
<h3 id="安装hexo插件"><a href="#安装hexo插件" class="headerlink" title="安装hexo插件"></a>安装hexo插件</h3><p>下载安装hexo<br>Node.js的第三方模块托管地址是<a href="https://www.npmjs.com/" target="_blank" rel="external">https://www.npmjs.com/</a>在这里我们能找到数以万计的Node.js第三方模块，node在安装的时候默认安装npm环境，这样我们就可以直接使用npm命令安装hexo</p>
<pre><code>npm install hexo
</code></pre><p>如果需要权限，在命令前面加上 sudo ,如果要全局安装，再加个 -g</p>
<h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><p>在当前博客目录下：</p>
<pre><code>hexo init
</code></pre><p>初始化完成后，文件内会默认生成播客相关的文件，一般包括：</p>
<ol>
<li>_config.yml 配置文件</li>
<li>node_modules 模块文件夹</li>
<li>package.json 插件记录文件</li>
<li>scaffolds  </li>
<li>source 里面放博客的md文件和一些主题里的配置文件</li>
<li>theme 里面放置主题文件</li>
<li>public  这个一般刚装上是没有的，在第一次 hexo -g生成静态文件后才有</li>
<li>等等</li>
</ol>
<h3 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h3><p>1.通过输入以下：</p>
<pre><code>hexo new 文章titil
</code></pre><p>通过该命令，系统会在source/_posts/目录下生成一个 文章titil.md 文件，然后通过md语法编辑博客内容就好了，特别简单的md语法在mou菜单下面的help下面的mou help里面。</p>
<p>2.直接在source/_posts/目录下新建或复制一份md文件，然后进行编辑。跟上面唯一的区别就是复制出来的文章的时间信息跟被复制的文件的时间一样，我们需要手动改一下（时间是可以随便改的哟），而通过终端创建出来的文件时间是创建文件那一刻的时间。</p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><pre><code>hexo g
</code></pre><p>g:generate 该命令将md文件和相关的配置文件生成浏览器可以解析的HTML和CSS以及js文件，并放到一个自动新建的public文件夹下</p>
<h3 id="本地查看"><a href="#本地查看" class="headerlink" title="本地查看"></a>本地查看</h3><pre><code>hexo s
</code></pre><p>或者 hexo server 运行本地服务器，运行完成后，下面会出现服务器地址 一般为 http//localhost:4000/<br>只要将这个地址在浏览器中打开就可以看到效果了，退出服务器运行环境 按 ctrl + c 就可以了</p>
<h3 id="将本地文件上线"><a href="#将本地文件上线" class="headerlink" title="将本地文件上线"></a>将本地文件上线</h3><h4 id="deployer"><a href="#deployer" class="headerlink" title="deployer"></a>deployer</h4><p>将hexo的本地文件上传到线上git，我们需要安装一个插件：hexo-deployer-git</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>通过–save 安装成功后 会在package.json文件里多出一行”hexo-deployer-git”: “^0.1.0”,的记录信息。 “^0.1.0”为版本号</p>
<h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>打开你的_config.yml配置文件，找到deploy，更改为：</p>
<pre><code>deploy:
      type: git
      repo: https://github.com/yourname/yourname.github.io.git
</code></pre><p>设置你域名仓库的ssh或https链接，让终端知道往哪里传。直接打开仓库，右边有个 Clone or download 点击后将里面的地址直接复制粘贴过来。注意冒号后面的空格；当然上面的yourname要改为你的git账户名</p>
<h4 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h4><p>安装好后，执行：</p>
<pre><code>hexo d
</code></pre><p>通过该命令会把生成好的静态文件上传到你的github，完成后，登入你的yourname.github.io就可以看到你的博客页面了</p>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>在上面运行的过程中如果出现如下类似错误:</p>
<pre><code>ERROR Process failed: layout/.DS_Store
</code></pre><p>进入主题里面的layout和_partial目录下,使用删除命令:</p>
<pre><code>rm -rf .DS_Store
</code></pre><p>强制移除此文件即可,如果还有可以多删几次</p>
<h3 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h3><p>如果你觉得自己的主题不够漂亮，你可以在 theme 文件夹下 你的主题文件里做更改。</p>
<p>你也可以直接在网上下载你喜欢的 hexo 主题，直接放到 theme 目录下，然后将_config.yml文件下 “theme: themeName”的themeName更改为你的主题文件夹名字，注意冒号后面有空格。</p>
<p>当然如果你够牛，你可以自己写自己的主题。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[github的下载与上传]]></title>
      <url>http://yoursite.com/2015/09/17/github/</url>
      <content type="html"><![CDATA[<h2 id="1-申请git账号"><a href="#1-申请git账号" class="headerlink" title="1.申请git账号"></a>1.申请git账号</h2><p>这个大家自己去git官网申请，申请地址：<a href="https://github.com/join?source=header-home" target="_blank" rel="external">https://github.com/join?source=header-home</a></p>
<h2 id="2-搭建本地环境"><a href="#2-搭建本地环境" class="headerlink" title="2.搭建本地环境"></a>2.搭建本地环境</h2><p>mac下通过安装Xcode来搭建git环境，xcode自带git环境。安装完成后，通过终端输入以下命令检测git环境：</p>
<pre><code>git --version 
</code></pre><p>出现 git version 数字序列的版本号就表示安装成功。<br><a id="more"></a></p>
<h2 id="3-创建仓库"><a href="#3-创建仓库" class="headerlink" title="3.创建仓库"></a>3.创建仓库</h2><p>在你的git主页面的右上角点击“加号”&gt;New reposltory（仓库简写repo），仓库名随便，比如：myTest.这个就好比在本地新建一个文件夹，再给文件夹命个名。<br>仓库创建完成后会生成一个ssh地址，就是你访问本库的连接</p>
<h2 id="4-克隆仓库"><a href="#4-克隆仓库" class="headerlink" title="4.克隆仓库"></a>4.克隆仓库</h2><p>通过终端输入以下命令：</p>
<pre><code>git clone 仓库ssh地址
</code></pre><p>本命令将在线仓库复制到本地当前文件夹（终端所在文件夹），比如我的当前目录下多出一个myTest文件夹</p>
<p>克隆语法：git clone  <name> <url> <directory></directory></url></name></p>
<p>这里，name(远程仓库名)可以不写，默认origin；directory是你要复制到的文件夹，也可以不写，默认使用远程git一样的根目录名</p>
<h2 id="5-上传仓库"><a href="#5-上传仓库" class="headerlink" title="5.上传仓库"></a>5.上传仓库</h2><p>接下来的操作都要先进入这个文件夹</p>
<pre><code>$ cd myTest
</code></pre><p>在本地添加或修改仓库文件后，我们要把仓库发布到线上托管起来，就需要上传仓库</p>
<h3 id="1-git-status"><a href="#1-git-status" class="headerlink" title="1). git status"></a>1). git status</h3><p>在终端输入 ：</p>
<pre><code>git status
</code></pre><p>我们可以查看仓库文件的修改状态（可以不查看），确定后，输入：</p>
<h3 id="2-git-add"><a href="#2-git-add" class="headerlink" title="2). git add"></a>2). git add</h3><pre><code>git add .
</code></pre><p>该命令跟踪新文件或者已有文件的改动，并把文件提交到缓存区，或者用来解决冲突， add后面是文件名  “.”代表所有文件</p>
<p>git add .命令除了能够判断出当前目录（包括其子目录）所有被修改或者已删除的文档，还能判断用户所添加的新文档，并将其信息追加到索引中。</p>
<h3 id="3-git-commit"><a href="#3-git-commit" class="headerlink" title="3) .git commit"></a>3) .git commit</h3><pre><code>git commit -m &quot;注释内容&quot;
</code></pre><p>git commit 把文件的修改记录到分支中，建立上传日志</p>
<p>使用 -m 选项直接添加提交信息（会记录到日志里），如果我们这里不用-m参数（message）的话，git将调到一个文本编译器（通常是vim）来让你输入提交的描述信息</p>
<h4 id="git仓库的组成"><a href="#git仓库的组成" class="headerlink" title="git仓库的组成"></a>git仓库的组成</h4><p>要理解上述代码 我们先来了解一下git仓库的组成，git系统由三种对象组成，分别是：</p>
<p>（1）提交（commit）</p>
<p>（2）树（tree）</p>
<p>（3）原文（blob）</p>
<p>先看一张图：</p>
<p><img src="http://o7sbm264p.bkt.clouddn.com/git1.png"></p>
<p>git的每一次提交是一个commit对象，这个对象中又包括这几个内容：</p>
<ul>
<li>tree对象：真正记录文件改变的记录，是tree的地址，指向真正的记录地址</li>
</ul>
<ul>
<li>author：文件的创建者，第一次是放在仓库的</li>
<li>commiter：就是这次是谁提交的</li>
<li>comment：这次提交的注释</li>
</ul>
<p>tree对象记录了这次提交的记录，每一个文件代表一个blob，指向一个文件地址。</p>
<p>tree里面还可以包括tree对象，就像目录可以有子目录。</p>
<p>上面这就是一次提交的commit操作的结果。是不是关系也搞懂了，概念也搞懂了。</p>
<p>每次提交git都会生成一个快照（snapshot），每提交一次生成一个快照，这次的快照是上次的快照基础上生成的。</p>
<p>请看下图：</p>
<p><img src="http://o7sbm264p.bkt.clouddn.com/git2.jpg"></p>
<p>一共提交了三次，生成了三次快照，这次快照将会完整的保存下来。每次快照都是在上一次快照的基础上生成的，第一次入仓库时也会提供一个快照。</p>
<p>这些生成的一个链条，就可以理解为一个分支。</p>
<p>git仓库存放在哪呢？就是在当前工作目录的.git文件夹（可能为隐藏文件夹）下。</p>
<ul>
<li>git/objects  存放所有的对象</li>
<li>git/heads   存放的所有分支，这里仅仅是一个引用，每个引用引用的都是该分支最后一次提交的记录。</li>
<li>git/refs/tags  所有的tag，方便以后查看的标签</li>
<li>git/logs/HEAD  HEAD的历史变化</li>
<li>git/refs/heads  除了master分支之外的其他分支HEAD的变化历史</li>
</ul>
<p>一般仓库中的文件可能存在于这三种状态：</p>
<ol>
<li>Untracked files → 文件未被跟踪；</li>
<li>Changes to be committed → 文件已暂存，这是下次提交的内容；</li>
<li>Changes but not updated → 文件被修改，但并没有添加到暂存区。如果 commit 时没有带 -a 选项，这个状态下的文件不会被提交。    </li>
</ol>
<p>git commit 提交的是暂存区里面的内容，也就是 Changes to be committed 中的文件。</p>
<p>git commit -a 把所有修改的文件先提交到stage,然后再从stash提交到branch</p>
<p>git commit -a 除了将暂存区里的文件提交外，还提交 Changes but not updated 中的文件。</p>
<p>git commit -am “描述信息”</p>
<p>git commit 命令的 -a即–all：commit all changed files, 可将所有被修改或者已删除的且已经被git管理的文档提交倒仓库中。如果只是修改或者删除了已被Git 管理的文档，是没必要使用git add 命令的。如果你有新添加的文件这条命令就不适用。</p>
<h3 id="4-修改-取消"><a href="#4-修改-取消" class="headerlink" title="4. 修改/取消"></a>4. 修改/取消</h3><p>有时候我们会发现有几个文件漏了提交或者想修改一下提交信息，又或者忘记使用 -a 选项导致一些文件没有被提交，我们希望对上一次提交进行修改，或者说取消上一次提交，这时候我们需要使用 –amend 选项。</p>
<p>比如我们发现在提交时忘记使用 -a 选项，导致 Changes but not updated 中的内容没有被提交，我们可以使用：</p>
<pre><code>git commit --amend -a
</code></pre><h3 id="配置本地用户"><a href="#配置本地用户" class="headerlink" title="配置本地用户"></a>配置本地用户</h3><pre><code>git config --global user.name &quot;Your Name&quot;
git config --global user.email &quot;email@example.com&quot;
</code></pre><p>在本地配置你的用户名和邮箱，这个将被记录到日志文件中，说明是那个用户上传的，如果就你自己上传，这个信息在本地配置一次就可以了；如果加–global（注意是两个“-”）就是全局配置</p>
<h3 id="上传到线上仓库"><a href="#上传到线上仓库" class="headerlink" title="上传到线上仓库"></a>上传到线上仓库</h3><pre><code>git remote add origin git@github.com:yourname/learngit.git
git push -u origin master
</code></pre><p>这一步执行的时候，如果让你输入用户名密码等，就是你的git账号密码</p>
<p>第一句 origin是远程仓库名 后面的是你仓库的地址</p>
<p>第二句语法： git push <remote name=""> <branchname></branchname></remote></p>
<p>尖括号部分可选内容。其中origin是远程仓库名，master是分支名；如果是第一次提交建议加上origin和master</p>
<p><code>完事进入自己的线上仓库就可以看得到了</code></p>
<h3 id="SSH-key"><a href="#SSH-key" class="headerlink" title="SSH key"></a>SSH key</h3><p>按说到这里已经结束了，但我觉得每次远程连接的时候都要验证身份（虽然这样更安全）挺烦的，所以我们可以通过生成本机ssh key钥匙，绑定到git里面，就不用每次连接都验证了。</p>
<p>1.我们先登录到github页面，点击 账户右面的下三角 &gt; Settings &gt; 左侧SSH and GPG keys &gt; 右上角有一个 new ssh key  点击后，随便取一个title(you happy is good),让git来辨别是哪个机器，key看下一步</p>
<p>2.然后来获取一下钥匙，先进入到终端，输入：</p>
<pre><code>ssh-keygen
vim ~/.ssh/id_rsa.pub
</code></pre><p>然后就是一阵狂回车，直到出来一个ssh开头.local结束的一长串，将其复制（不要多复制），粘贴到上一步的key中保存即可</p>
<p>3.接下来我们先退出vim环境，输一个冒号“：”（即shift+分号；）,再输入一个q,回车就退出了；</p>
<p>然后我们来测试一下链接，输入：</p>
<pre><code>ssh git@github.com
</code></pre><p>出现</p>
<pre><code>The authenticity of host &apos;github.com (192.30.252.123)&apos; can&apos;t be established.
RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.
Are you sure you want to continue connecting (yes/no)? 
</code></pre><p>输入yes回车，</p>
<pre><code>Warning: Permanently added &apos;github.com,192.30.252.123&apos; (RSA) to the list of known hosts.
PTY allocation request failed on channel 0
Hi gaoke700! You&apos;ve successfully authenticated, but GitHub does not provide shell access.
Connection to github.com closed.
</code></pre><p>出现上述提示信息说明连接成功</p>
<p><code>终于写完了，累死宝宝了，本博客内容有不对的欢迎纠正</code></p>
<p>更多git基本概念<a href="http://www.cnblogs.com/wilber2013/category/643754.html" target="_blank" rel="external">http://www.cnblogs.com/wilber2013/category/643754.html</a></p>
<p><a href="http://www.360doc.com/content/15/0302/19/12144668_452042045.shtml" target="_blank" rel="external">github超详细图文攻略</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jquery中attr和prop的区别]]></title>
      <url>http://yoursite.com/2015/08/26/attrANDprop/</url>
      <content type="html"><![CDATA[<p>在高版本的jquery引入prop方法后，什么时候该用prop？什么时候用attr？它们两个之间有什么区别？这些问题就出现了。</p>
<p>关于它们两个的区别，网上的答案很多。这里谈谈我的心得，我的心得很简单：</p>
<ul>
<li>对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。</li>
</ul>
<ul>
<li>对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。<a id="more"></a>
上面的描述也许有点模糊，举几个例子就知道了。 </li>
</ul>
<pre>    
&lt;a href="http://www.baidu.com" target="_self" class="btn">百度&lt;/a>
</pre>

<p>这个例子里&lt;a&gt;元素的DOM属性有“href、target和class”，这些属性就是&lt;a&gt;元素本身就带有的属性，也是W3C标准里就包含有这几个属性，或者说在IDE里能够智能提示出的属性，这些就叫做固有属性。处理这些属性时，建议使用prop方法。</p>
<p><pre><br>&lt;a href=”#” id=”link1” action=”delete”&gt;删除&lt;/a&gt;<br></pre><br>这个例子里&lt;a&gt;元素的DOM属性有“href、id和action”，很明显，前两个是固有属性，而后面一个“action”属性是我们自己自定义上去的，&lt;a&gt;元素本身是没有这个属性的。这种就是自定义的DOM属性。处理这些属性时，建议使用attr方法。使用prop方法取值和设置属性值时，都会返回undefined值。</p>
<p>再举一个例子：</p>
<pre><code>input id=&quot;chk1&quot; type=&quot;checkbox&quot; /&gt;是否可见
&lt;input id=&quot;chk2&quot; type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt;是否可见
</code></pre><p>像checkbox，radio和select这样的元素，选中属性对应“checked”和“selected”，这些也属于固有属性，因此需要使用prop方法去操作才能获得正确的结果。</p>
<pre><code>$(&quot;#chk1&quot;).prop(&quot;checked&quot;) == false
$(&quot;#chk2&quot;).prop(&quot;checked&quot;) == true
</code></pre><p>如果上面使用attr方法，则会出现：</p>
<pre><code>$(&quot;#chk1&quot;).attr(&quot;checked&quot;) == undefined
$(&quot;#chk2&quot;).attr(&quot;checked&quot;) == &quot;checked&quot;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[sublime text3快捷键]]></title>
      <url>http://yoursite.com/2015/04/14/sublimeText3/</url>
      <content type="html"><![CDATA[<h3 id="选择类"><a href="#选择类" class="headerlink" title="选择类"></a>选择类</h3><p>Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。</p>
<p>Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。</p>
<p>Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。</p>
<p>Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。</p>
<p>Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。<br><a id="more"></a></p>
<p>Ctrl+M 光标移动至括号内结束或开始的位置。</p>
<p>Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。</p>
<p>Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。</p>
<p>Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。</p>
<p>Ctrl+Shift+] 选中代码，按下快捷键，展开代码。</p>
<p>Ctrl+K+0 展开所有折叠代码。</p>
<p>Ctrl+← 向左单位性地移动光标，快速移动光标。</p>
<p>Ctrl+→ 向右单位性地移动光标，快速移动光标。</p>
<p>shift+↑ 向上选中多行。</p>
<p>shift+↓ 向下选中多行。</p>
<p>Shift+← 向左选中文本。</p>
<p>Shift+→ 向右选中文本。</p>
<p>Ctrl+Shift+← 向左单位性地选中文本。</p>
<p>Ctrl+Shift+→ 向右单位性地选中文本。</p>
<p>Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。</p>
<p>Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。</p>
<p>Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。</p>
<p>Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。</p>
<h3 id="编辑类"><a href="#编辑类" class="headerlink" title="编辑类"></a>编辑类</h3><p>Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。</p>
<p>Ctrl+Shift+D 复制光标所在整行，插入到下一行。</p>
<p>Tab 向右缩进。</p>
<p>Shift+Tab 向左缩进。</p>
<p>Ctrl+K+K 从光标处开始删除代码至行尾。</p>
<p>Ctrl+Shift+K 删除整行。</p>
<p>Ctrl+/ 注释单行。</p>
<p>Ctrl+Shift+/ 注释多行。</p>
<p>Ctrl+K+U 转换大写。</p>
<p>Ctrl+K+L 转换小写。</p>
<p>Ctrl+Z 撤销。</p>
<p>Ctrl+Y 恢复撤销。</p>
<p>Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。</p>
<p>Ctrl+F2 设置书签</p>
<p>Ctrl+T 左右字母互换。</p>
<p>F6 单词检测拼写</p>
<h3 id="搜索类"><a href="#搜索类" class="headerlink" title="搜索类"></a>搜索类</h3><p>Ctrl+F 打开底部搜索框，查找关键字。</p>
<p>Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。</p>
<p>Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。</p>
<p>Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。</p>
<p>Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。</p>
<p>Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。</p>
<p>Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。</p>
<p>Esc 退出光标多行选择，退出搜索框，命令框等。</p>
<h3 id="显示类"><a href="#显示类" class="headerlink" title="显示类"></a>显示类</h3><p>Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。</p>
<p>Ctrl+PageDown 向左切换当前窗口的标签页。</p>
<p>Ctrl+PageUp 向右切换当前窗口的标签页。</p>
<p>Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字）</p>
<p>Alt+Shift+2 左右分屏-2列</p>
<p>Alt+Shift+3 左右分屏-3列</p>
<p>Alt+Shift+4 左右分屏-4列</p>
<p>Alt+Shift+5 等分4屏</p>
<p>Alt+Shift+8 垂直分屏-2屏</p>
<p>Alt+Shift+9 垂直分屏-3屏</p>
<p>Ctrl+K+B 开启/关闭侧边栏。</p>
<p>F11 全屏模式</p>
<p>Shift+F11 免打扰模式</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[clearfix清除浮动进化史]]></title>
      <url>http://yoursite.com/2015/03/17/clearfix/</url>
      <content type="html"><![CDATA[<h2 id="clearfix清除浮动"><a href="#clearfix清除浮动" class="headerlink" title="clearfix清除浮动"></a>clearfix清除浮动</h2><p>首先在很多很多年以前我们常用的清除浮动是这样的。</p>
<pre><code>.clear{clear:both;line-height:0;}
</code></pre><p>现在可能还可以在很多老的站点上可以看到这样的代码，相当暴力有效的解决浮动的问题。</p>
<p>但是这个用法有一个致命伤，就是每次清除浮动的时候都需要增加一个空标签来使用。这种做法如果在页面复杂的布局要经常清楚浮动的时候就会产生很多的空标签，增加了页面无用标签，不利于页面优化。<br><a id="more"></a><br>因此有很多大神就研究出了 clearfix 清除浮动的方法，直接解决了上面的缺陷，不需要增加空标签，直接在有浮动的外层加上这个样式就可以了，这也是我们今天要讨论的clearfix进化史。</p>
<h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><pre><code>.clearfix:after { 
       visibility: hidden; 
        display: block; 
    font-size: 0; 
    content: &quot; &quot;; 
    clear: both; 
    height: 0; 
} 
.clearfix { display: inline-table; } 

* html .clearfix { height: 1%; }        //Hides from IE-mac 
.clearfix { display: block; }            //End hide from IE-mac
</code></pre><p>解释一下以上的代码：</p>
<ul>
<li>对大多数符合标准的浏览器应用第一个声明块，目的是创建一个隐形的内容为空的块来为目标元素清除浮动。</li>
<li>第二条为clearfix应用 inline-table 显示属性，仅仅针对IE/Mac。利用 * 对 IE/Mac 隐藏一些规则：</li>
<li>height:1% 用来触发 IE6 下的haslayout。</li>
<li><p>重新对 IE/Mac 外的IE应用 block 显示属性。</p>
</li>
<li><p>最后一行用于结束针对 IE/Mac 的hack。（是不是觉得很坑爹，Mac下还有IE）</p>
</li>
</ul>
<p>起源代码可能也是很早期的时候了，再往后Mac下的IE5也发展到IE6了，各种浏览器开始向W3C这条标准慢慢靠齐了。所以就有了下面这个写法出现了。</p>
<pre><code>.clearfix:after { 
    visibility: hidden; 
    display: block; 
    font-size: 0; 
    content: &quot; &quot;; 
    clear: both; 
    height: 0; 
} 
* html .clearfix { zoom: 1; }                  /* IE6 */
*:first-child+html .clearfix { zoom: 1; }     /* IE7 */
</code></pre><p>IE6 和 IE7 都不支持 :after 这个伪类，因此需要后面两条来触发IE6/7的haslayout，以清除浮动。幸运的是IE8支持 :after 伪类。因此只需要针对IE6/7的hack了。</p>
<p>在一个有float 属性元素的外层增加一个拥有clearfix属性的div包裹，可以保证外部div的height，即清除”浮动元素脱离了文档流，包围图片和文本的 div 不占据空间”的问题。</p>
<p>Jeff Starr 在这里针对IE6/7用了两条语句来触发haslayout。我在想作者为什么不直接用 * 来直接对 IE6/7 同时应用 zoom:1 或者直接就写成：</p>
<pre><code>.clearfix:after { 
    visibility: hidden; 
    display: block; 
    font-size: 0; 
    content: &quot; &quot;; 
    clear: both; 
    height: 0; 
} 
.clearfix{*zoom:1;}
</code></pre><p>　　但是对于很多同学这种优化程度代码还是不够给力，clearfix 发展到现在的两个终极版。</p>
<h3 id="重构clearfix浮动"><a href="#重构clearfix浮动" class="headerlink" title="重构clearfix浮动"></a>重构clearfix浮动</h3><p>构成Block Formatting Context的方法有下面几种： </p>
<ul>
<li><p>float的值不为none。</p>
</li>
<li><p>overflow的值不为visible。</p>
</li>
<li><p>display的值为table-cell, table-caption, inline-block中的任何一个。 </p>
</li>
<li><p>position的值不为relative和static。 </p>
</li>
</ul>
<p>很明显，float和position不合适我们的需求。那只能从overflow或者display中选取一个。</p>
<p>因为是应用了.clearfix和.menu的菜单极有可能是多级的，所以overflow: hidden或overflow: auto也不满足需求（会把下拉的菜单隐藏掉或者出滚动条），那么只能从display下手。 </p>
<p>我们可以将.clearfix的display值设为table-cell, table-caption, inline-block中的任何一个</p>
<p>但是display: inline-block会产生多余空白，所以也排除掉。</p>
<p>剩下的只有table-cell, table-caption，为了保证兼容可以用display: table来使.clearfix形成一个Block Formatting Context</p>
<p>因为display: table会产生一些匿名盒子，这些匿名盒子的其中一个（display值为table-cell）会形成Block Formatting Context。</p>
<p>这样我们新的.clearfix就会闭合内部元素的浮动。</p>
<p>后面又有人对此进行了改良：</p>
<h4 id="终极版一："><a href="#终极版一：" class="headerlink" title="终极版一："></a>终极版一：</h4><pre><code>.clearfix:after { 
    content:&quot;\200B&quot;; 
    display:block; 
    height:0; 
    clear:both; 
} 
.clearfix {*zoom:1;}    /*IE/7/6*/
</code></pre><p>　　解释下:content:”\200B”;这个参数，Unicode字符里有一个“零宽度空格”，即 U+200B，代替原来的“.”，可以缩减代码量。而且不再使用visibility:hidden。</p>
<h4 id="终极版二："><a href="#终极版二：" class="headerlink" title="终极版二："></a>终极版二：</h4><pre><code>.clearfix:before,.clearfix:after{ 
    content:&quot;&quot;; 
    display:table; 
} 
.clearfix:after{clear:both;} 
.clearfix{ 
    *zoom:1;    /*IE/7/6*/
}
</code></pre><p>　　这两个终极版代码都很简洁，终极版一和二都可以使用。<br>　　<br>　本文参考<a href="http://www.admin10000.com/document/6259.html" target="_blank" rel="external">http://www.admin10000.com/document/6259.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的主题配置]]></title>
      <url>http://yoursite.com/2015/02/24/themeSet/</url>
      <content type="html"><![CDATA[<h2 id="hexo-theme-raytaylorism-v2"><a href="#hexo-theme-raytaylorism-v2" class="headerlink" title="hexo-theme-raytaylorism v2"></a>hexo-theme-raytaylorism v2</h2><p>raytaylorism是一款清新的的响应式Material Design风格的<a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>主题。该主题支持最新的Hexo 3.1版本。</p>
<p><strong>本主题不再支持Hexo 2.x版本，请使用本主题前备份你的数据并升级到Hexo 3。</strong></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd yourblog</span><br><span class="line">git clone https://github.com/raytaylorlin/hexo-theme-raytaylorism.git themes/raytaylorism</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>请不定期<code>git pull</code>一下主题以便获得最新的功能。<strong>请在pull之前先备份好你原来的配置。</strong></p>
<h2 id="启用（重要）"><a href="#启用（重要）" class="headerlink" title="启用（重要）"></a>启用（重要）</h2><ol>
<li>修改 <code>_config.yml</code> 中的<code>theme</code>一项的值为<code>raytaylorism</code></li>
<li>由于本主题使用了<a href="https://hexo.io/docs/data-files.html" target="_blank" rel="external">Data Files</a>数据文件和额外的layout文件，所以请复制以下文件到你的博客目录中，否则在启动server时可能会报错<ul>
<li><strong>复制<code>yourblog/themes/raytaylorism/_data</code>文件夹到<code>yourblog/source</code>目录下</strong></li>
<li><strong>复制<code>yourblog/themes/raytaylorism/_md/</code>下所有文件夹（about和reading）到<code>yourblog/source</code>目录下</strong></li>
</ul>
</li>
<li>在你的<code>yourblog/_config.yml</code>配置文件的<code>#pagination</code>的位置添加下面配置（禁用归档、标签、目录页面的分页功能）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">archive_generator:</span><br><span class="line">  per_page: 0</span><br><span class="line">tag_generator:</span><br><span class="line">  per_page: 0</span><br><span class="line">category_generator:</span><br><span class="line">  per_page: 0</span><br></pre></td></tr></table></figure>
<h2 id="配置指南（重要）"><a href="#配置指南（重要）" class="headerlink" title="配置指南（重要）"></a>配置指南（重要）</h2><p>本主题作者博文<a href="http://raytaylorlin.com/daily/hexo-theme-raytaylorism-v2/" target="_blank" rel="external">《新版Hexo主题Raytaylorism v2发布》</a>写了一些本指南没有涉及到的主题使用小技巧，可以作为参考。其余配置细节，还是以本指南的说明为主。</p>
<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><ul>
<li><strong>主题颜色配置</strong>：如果对主题的配色不满意，可以自行在<code>yourblog/themes/raytaylorism/_config.yml</code>中的<code>color</code>一项进行配置。其中各部件的颜色字符串命名遵循<a href="http://materializecss.com/color.html#palette" target="_blank" rel="external">Materializecss色板</a>规范。注意：<code>link</code>、<code>article_title_link</code>和<code>tab</code>配置的是文字的颜色，<strong>因此不可以给这几项配置<code>lighten</code>和<code>darken</code>的颜色加亮加暗的后缀</strong>。</li>
<li><strong>页面标题</strong>：在<code>yourblog/_config.yml</code>中，<code>title</code>项决定了页面header中显示的标题，<code>subtitle</code>决定了浏览器的<code>&lt;title&gt;</code>标签内容。</li>
<li><strong>favicon</strong>：请将<code>yourblog/themes/raytaylorism/source/favicon.png</code>替换为你自己的图标文件，<strong>保持<code>favicon.png</code>命名不变</strong>。</li>
<li><strong>多语言</strong>：目前主题支持简体中文、繁体中文和英文三种语言，可以将<code>yourblog/_config.yml</code>中<code>language</code>一项设置为<code>zh-CN</code>、<code>zh-TW</code>、<code>en</code>实现</li>
</ul>
<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><ul>
<li><strong>外部链接</strong>：在<code>yourblog/source/_data/link.json</code>数据文件中进行配置<ul>
<li>社交平台：对应<code>social</code>项，预设有<code>weibo</code>和<code>github</code>两种，如果需要其他社交平台可自行追加，但要注意<strong>key值必须与<a href="https://fortawesome.github.io/Font-Awesome/icons/" target="_blank" rel="external">Font Awesome图标</a>相对应，否则可能无法正常显示</strong>。</li>
<li>友情链接：对应<code>extern</code>项，其中key值为链接文字，value值为外链URL</li>
</ul>
</li>
<li><strong>首页幻灯片</strong>：在<code>yourblog/source/_data/slider.json</code>数据文件中进行配置。可以配置背景图、标题、副标题、对齐方式。如果不需要幻灯片，直接把<code>slider.json</code>删除即可。</li>
<li><strong>关于页面</strong>：<code>yourblog/themes/raytaylorism/_md/about/index.md</code>文件为自我介绍的正文，只需要像平时写博文一样正常地书写markdown即可。在<code>yourblog/source/_data/about.json</code>数据文件中配置关于页面的其他项。<ul>
<li><code>avatar</code>：String类型，头像图片链接</li>
<li><code>name</code>：String类型，自己的姓名</li>
<li><code>tag</code>: String类型，描述自己的标签，<strong>主要显示在侧滑栏的头部</strong></li>
<li><code>desc</code>：String类型，对自己的简短描述</li>
<li><code>skills</code>：Object类型，对象技能展示。对象key值为技能名，value值为评分（取值为0-10的整数），取值为-1为分隔线。若不需要则将该字段设为null</li>
<li><code>projects</code>：Array类型，作品与项目展示，内含多个Object，每个Object都有<code>name</code>作品名、<code>image</code>封面、<code>description</code>作品描述、<code>link_text</code>链接文字、<code>link</code>链接地址。若不需要则将该字段设为null</li>
<li><code>reward</code>：Array类型，打赏二维码图片列表。例子中两个图片分别为微信和支付宝的二维码图片链接。若不需要则将该字段设为null</li>
</ul>
</li>
<li><strong>读书页面</strong>：在<code>yourblog/source/_data/reading.json</code>数据文件中进行配置。读书页面有“已读”“在读”和“想读”三栏，分别对应<code>contents</code>项中的<code>readed</code>、<code>reading</code>和<code>wanted</code>字段，每个字段对应一个书籍列表，按照例子进行修改即可。</li>
<li><strong>new标签</strong>：在<code>yourblog/source/_data/hint.json</code>数据文件中进行配置。<code>selector</code>项是一个数组，里面可以包含若干个CSS选择器用于选择要添加new标签的DOM元素。</li>
</ul>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul>
<li><strong>代码语法高亮</strong>：语法高亮的主题默认由CSS文件<code>yourblog/themes/raytaylorism/source/css/lib/prettify-tomorrow-night-eighties.css</code>。如果需要替换，可以到<a href="http://jmblog.github.io/color-themes-for-google-code-prettify/" target="_blank" rel="external">Prettify Theme</a>选择你喜欢的主题，下载主题的CSS文件并存放到相同的目录下，并将<code>yourblog/themes/raytaylorism/_config.yml</code>中的<code>google_code_prettify_theme</code>一项改为对应的文件名。</li>
<li><strong>评论</strong>：评论插件默认使用<a href="http://duoshuo.com/" target="_blank" rel="external">多说</a>，需要自行配置<code>yourblog/themes/raytaylorism/_config.yml</code>中的<code>duoshuo_shortname</code>为你自己站点的shortname</li>
<li><p><strong>搜索</strong>：安装<a href="https://github.com/PaicHyperionDev/hexo-generator-search" target="_blank" rel="external">hexo-generator-search</a>，在<code>yourblog/_config.yml</code>中添加如下配置代码。如果不需要搜索功能，将<code>yourblog/themes/raytaylorism/_config.yml</code>中<code>menu</code>的<code>-id: search</code>那一整项删除即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: all</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>RSS</strong>：安装<a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="external">hexo-generator-feed</a>，并按照说明配置（<code>atom.xml</code>的链接写在<code>yourblog/source/_data/link.json</code>的social项中，一般无需更改）</p>
</li>
<li><strong>站点分析</strong>：<ul>
<li>Google分析：<code>yourblog/themes/raytaylorism/_config.yml</code>中的<code>google_analytics</code>一项改为你的<strong>Google分析track id</strong>，留空则不启用</li>
<li>腾讯分析：（国内用户有Google分析被墙的可能）<code>yourblog/themes/raytaylorism/_config.yml</code>中的<code>tencent_analytics</code>一项改为你的<strong>sId</strong>（在腾讯分析添加站点后，复制代码中<code>sId=xxxxxxxx</code>那串数字就是sId），留空则不启用</li>
<li>如果你需要其他第三方的站点统计，可以仿照上面的例子添加配置，并在<code>yourblog/themes/raytaylorism/layout/_partial/plugin/analytics.ejs</code>中添加相应的统计代码</li>
</ul>
</li>
</ul>
<h2 id="使用的插件"><a href="#使用的插件" class="headerlink" title="使用的插件"></a>使用的插件</h2><ul>
<li>样式框架：<a href="http://materializecss.com/" target="_blank" rel="external">Materialize</a></li>
<li>代码语法高亮：<a href="https://code.google.com/p/google-code-prettify/" target="_blank" rel="external">Google-code-prettify</a></li>
<li>流量分析：<a href="http://www.google.com/analytics/" target="_blank" rel="external">Google Analytics</a>、<a href="http://v2.ta.qq.com/" target="_blank" rel="external">腾讯分析</a></li>
<li>第三方社会化评论：<a href="http://duoshuo.com/" target="_blank" rel="external">多说</a></li>
</ul>
<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><ul>
<li>2.2.0(2016-4-22) 新增搜索功能</li>
<li>2.1.3(2016-4-13) 修复多行代码被挤到下方的显示问题</li>
<li>2.1.2(2016-4-5) 优化二级无序列表的样式，修复标签页和分类页的pagenav链接重复显示了两次导致404的问题</li>
<li>2.1.1(2016-3-29) 优化正文表格和引用的显示</li>
<li>2.1.0(2016-3-28) 增加对繁体中文和英文的支持</li>
<li>2.0.0-alpha(2016-3-14) 发布raytaylorism v2 alpha版本</li>
</ul>
<p><a href="log.md">历史记录</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Welcome to Hexo!]]></title>
      <url>http://yoursite.com/2014/12/24/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
